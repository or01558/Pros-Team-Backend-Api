"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const PartyPermissionError_1 = tslib_1.__importDefault(require("../exceptions/PartyPermissionError"));
const PartyMemberMeta_1 = tslib_1.__importDefault(require("./PartyMemberMeta"));
const User_1 = tslib_1.__importDefault(require("./User"));
/**
 * Represents a party member
 */
class PartyMember extends User_1.default {
    /**
     * @param party The party this member belongs to
     * @param data The member's data
     */
    constructor(party, data) {
        super(party.client, {
            ...data,
            displayName: data.account_dn,
            id: data.account_id,
        });
        this.party = party;
        this.role = data.role;
        this.joinedAt = new Date(data.joined_at);
        this.meta = new PartyMemberMeta_1.default(data.meta);
        this.revision = data.revision;
        this.receivedInitialStateUpdate = false;
    }
    /**
     * Whether this member is the leader of the party
     */
    get isLeader() {
        return this.role === 'CAPTAIN';
    }
    /**
     * The member's currently equipped outfit CID
     */
    get outfit() {
        return this.meta.outfit;
    }
    /**
     * The member's currently equipped pickaxe ID
     */
    get pickaxe() {
        return this.meta.pickaxe;
    }
    /**
     * The member's current emote EID
     */
    get emote() {
        return this.meta.emote;
    }
    /**
     * The member's currently equipped backpack BID
     */
    get backpack() {
        return this.meta.backpack;
    }
    /**
     * Whether the member is ready
     */
    get isReady() {
        return this.meta.isReady;
    }
    /**
     * The member's current input method
     */
    get inputMethod() {
        return this.meta.input;
    }
    /**
     * The member's cosmetic variants
     */
    get variants() {
        return this.meta.variants;
    }
    /**
     * The member's custom data store
     */
    get customDataStore() {
        return this.meta.customDataStore;
    }
    /**
     * The member's banner info
     */
    get banner() {
        return this.meta.banner;
    }
    /**
     * The member's battlepass info
     */
    get battlepass() {
        return this.meta.battlepass;
    }
    /**
     * The member's platform
     */
    get platform() {
        return this.meta.platform;
    }
    /**
     * The member's match info
     */
    get matchInfo() {
        return this.meta.match;
    }
    /**
     * Whether a marker has been set
     */
    get isMarkerSet() {
        return this.meta.isMarkerSet;
    }
    /**
     * The member's marker location [x, y] tuple.
     * [0, 0] if there is no marker set
     */
    get markerLocation() {
        return this.meta.markerLocation;
    }
    /**
     * The member's assisted challenge
     */
    get assistedChallenge() {
        return this.meta.assistedChallenge;
    }
    /**
     * Kicks this member from the client's party.
     * @throws {PartyPermissionError} The client is not a member or not the leader of the party
     */
    async kick() {
        // This is a very hacky solution, but it's required since we cannot import ClientParty (circular dependencies)
        if (typeof this.party.kick !== 'function')
            throw new PartyPermissionError_1.default();
        return this.party.kick(this.id);
    }
    /**
     * Promotes this member
     * @throws {PartyPermissionError} The client is not a member or not the leader of the party
     */
    async promote() {
        // This is a very hacky solution, but it's required since we cannot import ClientParty (circular dependencies)
        if (typeof this.party.promote !== 'function')
            throw new PartyPermissionError_1.default();
        return this.party.promote(this.id);
    }
    /**
     * Hides this member
     * @param hide Whether the member should be hidden
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {EpicgamesAPIError}
     */
    async hide(hide = true) {
        // This is a very hacky solution, but it's required since we cannot import ClientParty (circular dependencies)
        if (typeof this.party.hideMember !== 'function')
            throw new PartyPermissionError_1.default();
        return this.party.hideMember(this.id, hide);
    }
    /**
     * Updates this members data
     * @param data The update data
     */
    updateData(data) {
        if (data.revision > this.revision)
            this.revision = data.revision;
        if (data.account_dn !== this.displayName)
            this.update({ id: this.id, displayName: data.account_dn, externalAuths: this.externalAuths });
        this.meta.update(data.member_state_updated, true);
        this.meta.remove(data.member_state_removed);
    }
    /**
     * Converts this party member into an object
     */
    toObject() {
        return {
            id: this.id,
            account_id: this.id,
            joined_at: this.joinedAt.toISOString(),
            updated_at: new Date().toISOString(),
            meta: this.meta.schema,
            revision: 0,
            role: this.role,
            account_dn: this.displayName,
        };
    }
}
exports.default = PartyMember;
//# sourceMappingURL=PartyMember.js.map