"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Base_1 = tslib_1.__importDefault(require("../../client/Base"));
const PartyPermissionError_1 = tslib_1.__importDefault(require("../../exceptions/PartyPermissionError"));
/**
 * Represents a party received by a friend's presence
 */
class PresenceParty extends Base_1.default {
    /**
     * @param client The main client
     * @param data The presence party's data
     */
    constructor(client, data) {
        super(client);
        this.isPrivate = typeof data.bIsPrivate === 'boolean' || false;
        this.id = data.partyId;
        this.size = data.pc;
        this.typeId = data.partyTypeId;
        this.key = data.key;
        this.appId = data.appId;
        this.buildId = data.buildId;
        this.flags = data.partyFlags;
        this.notAcceptingMembersReason = data.notAcceptingReason;
    }
    /**
     * Joins this presence party
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched (the party is private)
     * @throws {PartyMaxSizeReachedError} The party has reached its max size
     */
    async join() {
        if (this.isPrivate || !this.id)
            throw new PartyPermissionError_1.default();
        await this.client.joinParty(this.id);
    }
    /**
     * Fetches this party
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched (the party is private)
     */
    async fetch() {
        if (this.isPrivate || !this.id)
            throw new PartyPermissionError_1.default();
        return this.client.getParty(this.id);
    }
}
exports.default = PresenceParty;
//# sourceMappingURL=PresenceParty.js.map