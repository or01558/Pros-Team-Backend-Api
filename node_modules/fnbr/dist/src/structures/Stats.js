"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Base_1 = tslib_1.__importDefault(require("../client/Base"));
const Util_1 = require("../util/Util");
/**
 * Represents a user's battle royale stats
 */
class Stats extends Base_1.default {
    /**
     * @param client The main client
     * @param data The stats' data
     */
    constructor(client, data, user) {
        super(client);
        this.data = data;
        this.user = user;
        this.startTime = new Date(data.startTime / 1000);
        this.endTime = new Date(data.endTime / 1000);
        this.levelData = {};
        this.stats = {
            all: (0, Util_1.createDefaultInputTypeStats)(),
            keyboardmouse: (0, Util_1.createDefaultInputTypeStats)(),
            gamepad: (0, Util_1.createDefaultInputTypeStats)(),
            touch: (0, Util_1.createDefaultInputTypeStats)(),
        };
        for (const key of Object.keys(data.stats)) {
            if (key.startsWith('br')) {
                const fields = key.split('_');
                fields.shift();
                const statKey = fields.shift();
                if (statKey !== 'collection') {
                    const inputType = fields.shift();
                    fields.shift();
                    const playlistId = fields.join('_');
                    const playlistType = typeof this.client.config.statsPlaylistTypeParser === 'function'
                        ? this.client.config.statsPlaylistTypeParser(playlistId)
                        : this.getPlaylistStatsType(playlistId);
                    if (playlistType !== 'other') {
                        const [parsedKey, parsedValue] = (0, Util_1.parseStatKey)(statKey, data.stats[key]);
                        const inputTypePlaylistStats = this.stats[inputType][playlistType];
                        const inputTypeAllStats = this.stats[inputType].overall;
                        const allPlaylistStats = this.stats.all[playlistType];
                        const allAllStats = this.stats.all.overall;
                        if (parsedKey === 'lastModified') {
                            if (!inputTypePlaylistStats.lastModified || parsedValue.getTime() > inputTypePlaylistStats.lastModified.getTime()) {
                                inputTypePlaylistStats.lastModified = parsedValue;
                            }
                            if (!inputTypeAllStats.lastModified || parsedValue.getTime() > inputTypeAllStats.lastModified.getTime()) {
                                inputTypeAllStats.lastModified = parsedValue;
                            }
                            if (!allPlaylistStats.lastModified || parsedValue.getTime() > allPlaylistStats.lastModified.getTime()) {
                                allPlaylistStats.lastModified = parsedValue;
                            }
                            if (!allAllStats.lastModified || parsedValue.getTime() > allAllStats.lastModified.getTime()) {
                                allAllStats.lastModified = parsedValue;
                            }
                        }
                        else {
                            inputTypePlaylistStats[parsedKey] += parsedValue;
                            if (playlistType !== 'ltm')
                                inputTypeAllStats[parsedKey] += parsedValue;
                            allPlaylistStats[parsedKey] += parsedValue;
                            if (playlistType !== 'ltm')
                                allAllStats[parsedKey] += parsedValue;
                        }
                    }
                }
            }
            else if (key.includes('social_bp_level')) {
                this.levelData[key.split('_')[0]] = {
                    level: Math.round(data.stats[key] / 100),
                    progress: data.stats[key] % 100,
                };
            }
        }
        for (const inputTypes of Object.keys(this.stats)) {
            for (const playlistTypeStats of Object.values(this.stats[inputTypes])) {
                playlistTypeStats.deaths = playlistTypeStats.matches - playlistTypeStats.wins;
                playlistTypeStats.kd = playlistTypeStats.kills / (playlistTypeStats.deaths || 1);
                playlistTypeStats.killsPerMin = playlistTypeStats.kills / (playlistTypeStats.minutesPlayed || 1);
                playlistTypeStats.killsPerMatch = playlistTypeStats.kills / (playlistTypeStats.matches || 1);
                playlistTypeStats.scorePerMin = playlistTypeStats.score / (playlistTypeStats.minutesPlayed || 1);
                playlistTypeStats.scorePerMatch = playlistTypeStats.score / (playlistTypeStats.matches || 1);
                playlistTypeStats.winRate = playlistTypeStats.wins / (playlistTypeStats.matches || 1);
            }
        }
    }
    /**
     * Returns the playlist stats type by the playlist id
     * @param playlistID The playlist ID
     */
    getPlaylistStatsType(playlistID) {
        const playlist = playlistID.toLowerCase().replace('playlist_', '');
        if (['creative', 'respawn', '16'].some((s) => playlist.includes(s)))
            return 'other';
        if (!['default', 'classic', 'showdown', 'vamp', 'unvaulted', 'toss', 'fill', 'heavy', 'tank', 'melt'].some((s) => playlist.includes(s)))
            return 'ltm';
        if (playlist.includes('solo'))
            return 'solo';
        if (playlist.includes('duo'))
            return 'duo';
        if (playlist.includes('trio'))
            return 'squad';
        if (playlist.includes('squad'))
            return 'squad';
        return 'other';
    }
}
exports.default = Stats;
//# sourceMappingURL=Stats.js.map