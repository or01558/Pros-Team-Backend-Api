import Client from '../../client/Client';
import User from '../user/User';
import { FriendConnections, FriendData } from '../../../resources/structs';
import FriendPresence from './FriendPresence';
import PresenceParty from '../party/PresenceParty';
/**
 * Represents a friend
 */
declare class Friend extends User {
    /**
     * The friend's console connections
     */
    connections: FriendConnections;
    /**
     * The mutual friends count.
     * Can be undefined if the friend was not friends with the client before startup
     */
    mutualFriends?: number;
    /**
     * Whether you favorited this friend
     */
    favorite: boolean;
    /**
     * The date when the friendship was created
     */
    createdAt: Date;
    /**
     * The note for this friend
     */
    note?: string;
    /**
     * The alias for this friend
     */
    alias?: string;
    /**
     * The last recieved presence of this friend
     */
    presence?: FriendPresence;
    /**
     * The friend's current party
     */
    party?: PresenceParty;
    /**
     * Timestamp when the last presence was recieved from this friend.
     * WARNING: Do not rely on this, it's set to undefined once this friend goes offline.
     * Use {@link FriendPresence#recievedAt} instead
     */
    lastAvailableTimestamp?: number;
    /**
     * @param client The main client
     * @param data The friend data
     */
    constructor(client: Client, data: FriendData);
    /**
     * Whether a user is online or not
     * @readonly
     */
    get isOnline(): boolean;
    /**
     * Whether the client can join this friend's party or not
     * May be slighly inaccurate as it uses the last received presence
     * @readonly
     */
    get isJoinable(): boolean;
    /**
     * Removes this friend
     * @throws {FriendNotFoundError} The user is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    remove(): Promise<void>;
    /**
     * Sends a message to this friend
     * @param content The message that will be sent
     * @throws {FriendNotFoundError} The user is not friends with the client
     */
    sendMessage(content: string): Promise<import("./SentFriendMessage").default>;
    /**
     * Sends a party join request to this friend.
     * When the friend confirms this, a party invite will be sent to the client
     * @throws {EpicgamesAPIError}
     */
    sendJoinRequest(): Promise<import("../party/SentPartyJoinRequest").default>;
    /**
     * Sends a party invitation to this friend
     * @throws {FriendNotFoundError} The user is not friends with the client
     * @throws {PartyAlreadyJoinedError} The user is already a member of this party
     * @throws {PartyMaxSizeReachedError} The party reached its max size
     * @throws {EpicgamesAPIError}
     */
    invite(): Promise<import("../party/SentPartyInvitation").default>;
    /**
     * Fetches the friends the client shares with this friend
     * @throws {FriendNotFoundError} The user is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    getMutualFriends(): Promise<Friend[]>;
    /**
     * Checks whether this friend owns a specific offer
     * @param offerId The offer id
     * @throws {OfferNotFoundError} The offer does not exist or is not in the current storefront catalog
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    checkOfferOwnership(offerId: string): Promise<boolean>;
}
export default Friend;
