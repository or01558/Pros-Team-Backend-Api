"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const collection_1 = tslib_1.__importDefault(require("@discordjs/collection"));
const async_queue_1 = require("@sapphire/async-queue");
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
const FriendNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/FriendNotFoundError"));
const PartyAlreadyJoinedError_1 = tslib_1.__importDefault(require("../exceptions/PartyAlreadyJoinedError"));
const PartyMaxSizeReachedError_1 = tslib_1.__importDefault(require("../exceptions/PartyMaxSizeReachedError"));
const PartyMemberNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/PartyMemberNotFoundError"));
const PartyPermissionError_1 = tslib_1.__importDefault(require("../exceptions/PartyPermissionError"));
const ClientPartyMeta_1 = tslib_1.__importDefault(require("./ClientPartyMeta"));
const Party_1 = tslib_1.__importDefault(require("./Party"));
const PartyChat_1 = tslib_1.__importDefault(require("./PartyChat"));
const SentPartyInvitation_1 = tslib_1.__importDefault(require("./SentPartyInvitation"));
/**
 * Represents a party that the client is a member of
 */
class ClientParty extends Party_1.default {
    /**
     * @param client The main client
     * @param data The party's data
     */
    constructor(client, data) {
        super(client, data instanceof Party_1.default ? data.toObject() : data);
        this.hiddenMemberIds = new Set();
        this.pendingMemberConfirmations = new collection_1.default();
        this.patchQueue = new async_queue_1.AsyncQueue();
        this.chat = new PartyChat_1.default(this.client, this);
        this.meta = new ClientPartyMeta_1.default(this, data instanceof Party_1.default ? data.meta.schema : data.meta);
    }
    /**
     * Returns the client's party member
     */
    get me() {
        var _a;
        return this.members.get((_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id);
    }
    /**
     * Whether the party is private
     */
    get isPrivate() {
        return this.config.privacy.partyType === 'Private';
    }
    /**
     * Leaves this party
     * @param createNew Whether a new party should be created
     * @throws {EpicgamesAPIError}
     */
    async leave(createNew = true) {
        var _a, _b;
        this.client.partyLock.lock();
        if (this.chat.isConnected)
            await this.chat.leave();
        const partyLeave = await this.client.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.BR_PARTY}/parties/${this.id}/members/${(_a = this.me) === null || _a === void 0 ? void 0 : _a.id}`, 'fortnite');
        if (partyLeave.error && ((_b = partyLeave.error) === null || _b === void 0 ? void 0 : _b.code) !== 'errors.com.epicgames.social.party.party_not_found') {
            this.client.partyLock.unlock();
            throw partyLeave.error;
        }
        this.client.party = undefined;
        this.client.partyLock.unlock();
        if (createNew)
            await this.client.createParty();
    }
    /**
     * Sends a party patch to Epicgames' servers
     * @param updated The updated schema
     * @param deleted The deleted schema keys
     * @throws {PartyPermissionError} You're not the leader of this party
     * @throws {EpicgamesAPIError}
     */
    async sendPatch(updated, deleted = []) {
        await this.patchQueue.wait();
        const patch = await this.client.http.sendEpicgamesRequest(true, 'PATCH', `${Endpoints_1.default.BR_PARTY}/parties/${this.id}`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            config: {
                join_confirmation: this.config.joinConfirmation,
                joinability: this.config.joinability,
                max_size: this.config.maxSize,
                discoverability: this.config.discoverability,
            },
            meta: {
                delete: deleted,
                update: updated || this.meta.schema,
            },
            party_state_overridden: {},
            party_privacy_type: this.config.joinability,
            party_type: this.config.type,
            party_sub_type: this.config.subType,
            max_number_of_members: this.config.maxSize,
            invite_ttl_seconds: this.config.inviteTtl,
            revision: this.revision,
        });
        if (patch.error) {
            if (patch.error.code === 'errors.com.epicgames.social.party.stale_revision') {
                this.revision = parseInt(patch.error.messageVars[1], 10);
                this.patchQueue.shift();
                return this.sendPatch(updated);
            }
            this.patchQueue.shift();
            if (patch.error.code === 'errors.com.epicgames.social.party.party_change_forbidden') {
                throw new PartyPermissionError_1.default();
            }
            throw patch.error;
        }
        this.revision += 1;
        this.patchQueue.shift();
        return undefined;
    }
    /**
     * Kicks a member from this party
     * @param member The member that should be kicked
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {PartyMemberNotFoundError} The party member wasn't found
     * @throws {EpicgamesAPIError}
     */
    async kick(member) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        const partyMember = this.members.find((m) => m.displayName === member || m.id === member);
        if (!partyMember)
            throw new PartyMemberNotFoundError_1.default(member);
        const kick = await this.client.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.BR_PARTY}/parties/${this.id}/members/${partyMember.id}`, 'fortnite');
        if (kick.error) {
            if (kick.error.code === 'errors.com.epicgames.social.party.party_change_forbidden')
                throw new PartyPermissionError_1.default();
            throw kick.error;
        }
    }
    /**
     * Sends a party invitation to a friend
     * @param friend The friend that will receive the invitation
     * @throws {FriendNotFoundError} The user is not friends with the client
     * @throws {PartyAlreadyJoinedError} The user is already a member of this party
     * @throws {PartyMaxSizeReachedError} The party reached its max size
     * @throws {EpicgamesAPIError}
     */
    async invite(friend) {
        var _a, _b;
        const resolvedFriend = this.client.friends.find((f) => f.id === friend || f.displayName === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        if (this.members.has(resolvedFriend.id))
            throw new PartyAlreadyJoinedError_1.default();
        if (this.size === this.maxSize)
            throw new PartyMaxSizeReachedError_1.default();
        let invite;
        if (this.isPrivate) {
            invite = await this.client.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_PARTY}/parties/${this.id}/invites/${resolvedFriend.id}?sendPing=true`, 'fortnite', {
                'Content-Type': 'application/json',
            }, {
                'urn:epic:cfg:build-id_s': this.client.config.partyBuildId,
                'urn:epic:conn:platform_s': this.client.config.platform,
                'urn:epic:conn:type_s': 'game',
                'urn:epic:invite:platformdata_s': '',
                'urn:epic:member:dn_s': (_a = this.client.user) === null || _a === void 0 ? void 0 : _a.displayName,
            });
        }
        else {
            invite = await this.client.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_PARTY}/user/${resolvedFriend.id}/pings/${(_b = this.client.user) === null || _b === void 0 ? void 0 : _b.id}`, 'fortnite', {
                'Content-Type': 'application/json',
            }, {
                'urn:epic:invite:platformdata_s': '',
            });
        }
        if (invite.error)
            throw invite.error;
        return new SentPartyInvitation_1.default(this.client, this, this.client.user, resolvedFriend, invite);
    }
    /**
     * Refreshes the member positions of this party
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {EpicgamesAPIError}
     */
    async refreshSquadAssignments() {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        await this.sendPatch({
            'Default:RawSquadAssignments_j': this.meta.refreshSquadAssignments(),
        });
    }
    /**
     * Sends a message to the party chat
     * @param content The message that will be sent
     */
    async sendMessage(content) {
        return this.chat.send(content);
    }
    /**
     * Updates this party's privacy settings
     * @param privacy The updated party privacy
     * @param sendPatch Whether the updated privacy should be sent to epic's servers
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {EpicgamesAPIError}
     */
    async setPrivacy(privacy, sendPatch = true) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        const updated = {};
        const deleted = [];
        const privacyMeta = this.meta.get('Default:PrivacySettings_j');
        if (privacyMeta) {
            updated['Default:PrivacySettings_j'] = this.meta.set('Default:PrivacySettings_j', {
                PrivacySettings: {
                    ...privacyMeta.PrivacySettings,
                    partyType: privacy.partyType,
                    bOnlyLeaderFriendsCanJoin: privacy.onlyLeaderFriendsCanJoin,
                    partyInviteRestriction: privacy.inviteRestriction,
                },
            });
        }
        updated['urn:epic:cfg:presence-perm_s'] = this.meta.set('urn:epic:cfg:presence-perm_s', privacy.presencePermission);
        updated['urn:epic:cfg:accepting-members_b'] = this.meta.set('urn:epic:cfg:accepting-members_b', privacy.acceptingMembers);
        updated['urn:epic:cfg:invite-perm_s'] = this.meta.set('urn:epic:cfg:invite-perm_s', privacy.invitePermission);
        if (privacy.partyType === 'Private') {
            deleted.push('urn:epic:cfg:not-accepting-members');
            updated['urn:epic:cfg:not-accepting-members-reason_i'] = this.meta.set('urn:epic:cfg:not-accepting-members-reason_i', 7);
            this.config.discoverability = 'INVITED_ONLY';
            this.config.joinability = 'INVITE_AND_FORMER';
        }
        else {
            deleted.push('urn:epic:cfg:not-accepting-members-reason_i');
            this.config.discoverability = 'ALL';
            this.config.joinability = 'OPEN';
        }
        this.meta.remove(deleted);
        if (sendPatch)
            await this.sendPatch(updated, deleted);
        this.config.privacy = {
            ...this.config.privacy,
            ...privacy,
        };
        return { updated, deleted };
    }
    /**
     * Sets this party's custom matchmaking key
     * @param key The custom matchmaking key
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {EpicgamesAPIError}
     */
    async setCustomMatchmakingKey(key) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        await this.sendPatch({
            'Default:CustomMatchKey_s': this.meta.set('Default:CustomMatchKey_s', key || ''),
        });
    }
    /**
     * Promotes a party member
     * @param member The member that should be promoted
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {PartyMemberNotFoundError} The party member wasn't found
     * @throws {EpicgamesAPIError}
     */
    async promote(member) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        const partyMember = this.members.find((m) => m.displayName === member || m.id === member);
        if (!partyMember)
            throw new PartyMemberNotFoundError_1.default(member);
        const promote = await this.client.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_PARTY}/parties/${this.id}/members/${partyMember.id}/promote`, 'fortnite');
        if (promote.error) {
            if (promote.error.code === 'errors.com.epicgames.social.party.party_change_forbidden')
                throw new PartyPermissionError_1.default();
            throw promote.error;
        }
    }
    /**
     * Hides / Unhides a single party member
     * @param member The member that should be hidden
     * @param hide Whether the member should be hidden
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {PartyMemberNotFoundError} The party member wasn't found
     * @throws {EpicgamesAPIError}
     */
    async hideMember(member, hide = true) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        const partyMember = this.members.find((m) => m.displayName === member || m.id === member);
        if (!partyMember)
            throw new PartyMemberNotFoundError_1.default(member);
        if (hide) {
            this.hiddenMemberIds.add(partyMember.id);
        }
        else {
            this.hiddenMemberIds.delete(partyMember.id);
        }
        await this.refreshSquadAssignments();
    }
    /**
     * Hides / Unhides all party members except for the client
     * @param hide Whether all members should be hidden
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {EpicgamesAPIError}
     */
    async hideMembers(hide = true) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        if (hide) {
            this.members.filter((m) => m.id !== this.me.id).forEach((m) => this.hiddenMemberIds.add(m.id));
        }
        else {
            this.hiddenMemberIds.clear();
        }
        await this.refreshSquadAssignments();
    }
    /**
     * Updates the party's playlist
     * @param playlist The new playlist
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {EpicgamesAPIError}
     */
    async setPlaylist(playlist) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        let data = this.meta.get('Default:PlaylistData_j');
        data = this.meta.set('Default:PlaylistData_j', {
            ...data,
            PlaylistData: {
                ...data.PlaylistData,
                ...playlist,
            },
        });
        await this.sendPatch({
            'Default:PlaylistData_j': data,
        });
    }
    /**
     * Updates the squad fill status of this party
     * @param fill Whether fill is enable or not
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {EpicgamesAPIError}
     */
    async setSquadFill(fill = true) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        await this.sendPatch({
            'Default:AthenaSquadFill_b': this.meta.set('Default:AthenaSquadFill_b', fill),
        });
    }
    /**
     * Updates the party's max member count
     * @param maxSize The new party max size (1-16)
     * @throws {PartyPermissionError} The client is not the leader of the party
     * @throws {RangeError} The new max member size must be between 1 and 16 (inclusive) and more than the current member count
     * @throws {EpicgamesAPIError}
     */
    async setMaxSize(maxSize) {
        if (!this.me.isLeader)
            throw new PartyPermissionError_1.default();
        if (maxSize < 1 || maxSize > 16)
            throw new RangeError('The new max member size must be between 1 and 16 (inclusive)');
        if (maxSize < this.size)
            throw new RangeError('The new max member size must be higher than the current member count');
        this.config.maxSize = maxSize;
        await this.sendPatch(this.meta.schema);
    }
}
exports.default = ClientParty;
//# sourceMappingURL=ClientParty.js.map