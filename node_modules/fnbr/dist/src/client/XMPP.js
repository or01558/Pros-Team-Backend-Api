"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const stanza_1 = require("stanza");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const Base_1 = tslib_1.__importDefault(require("./Base"));
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
const PartyMessage_1 = tslib_1.__importDefault(require("../structures/party/PartyMessage"));
const FriendPresence_1 = tslib_1.__importDefault(require("../structures/friend/FriendPresence"));
const Friend_1 = tslib_1.__importDefault(require("../structures/friend/Friend"));
const IncomingPendingFriend_1 = tslib_1.__importDefault(require("../structures/friend/IncomingPendingFriend"));
const OutgoingPendingFriend_1 = tslib_1.__importDefault(require("../structures/friend/OutgoingPendingFriend"));
const BlockedUser_1 = tslib_1.__importDefault(require("../structures/user/BlockedUser"));
const Party_1 = tslib_1.__importDefault(require("../structures/party/Party"));
const Util_1 = require("../util/Util");
const ReceivedPartyInvitation_1 = tslib_1.__importDefault(require("../structures/party/ReceivedPartyInvitation"));
const FriendNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/FriendNotFoundError"));
const ClientPartyMember_1 = tslib_1.__importDefault(require("../structures/party/ClientPartyMember"));
const PartyMember_1 = tslib_1.__importDefault(require("../structures/party/PartyMember"));
const PartyMemberNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/PartyMemberNotFoundError"));
const PartyMemberConfirmation_1 = tslib_1.__importDefault(require("../structures/party/PartyMemberConfirmation"));
const ReceivedPartyJoinRequest_1 = tslib_1.__importDefault(require("../structures/party/ReceivedPartyJoinRequest"));
const PresenceParty_1 = tslib_1.__importDefault(require("../structures/party/PresenceParty"));
const ReceivedFriendMessage_1 = tslib_1.__importDefault(require("../structures/friend/ReceivedFriendMessage"));
const PartyMemberMeta_1 = tslib_1.__importDefault(require("../structures/party/PartyMemberMeta"));
/**
 * Represents the client's XMPP manager
 * @private
 */
class XMPP extends Base_1.default {
    /**
     * @param client The main client
     */
    constructor(client) {
        super(client);
        this.stream = undefined;
        this.isDisconnecting = false;
        this.connectedTimestamp = undefined;
    }
    /**
     * Whether the XMPP agent is connected
     */
    get isConnected() {
        return !!this.stream && this.stream.sessionStarted;
    }
    /**
     * Returns the xmpp JID
     */
    get JID() {
        var _a;
        return (_a = this.stream) === null || _a === void 0 ? void 0 : _a.jid;
    }
    /**
     * Returns the xmpp resource
     */
    get resource() {
        var _a;
        return (_a = this.stream) === null || _a === void 0 ? void 0 : _a.config.resource;
    }
    /**
     * Creates the XMPP agent and binds it to XMPP#stream.
     * Also registers all events
     */
    setup() {
        var _a, _b, _c;
        this.stream = (0, stanza_1.createClient)({
            jid: `${(_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id}@${Endpoints_1.default.EPIC_PROD_ENV}`,
            server: Endpoints_1.default.EPIC_PROD_ENV,
            transports: {
                websocket: `wss://${Endpoints_1.default.XMPP_SERVER}`,
                bosh: false,
            },
            credentials: {
                host: Endpoints_1.default.EPIC_PROD_ENV,
                username: (_b = this.client.user) === null || _b === void 0 ? void 0 : _b.id,
                password: (_c = this.client.auth.auths.get('fortnite')) === null || _c === void 0 ? void 0 : _c.token,
            },
            resource: `V2:Fortnite:${this.client.config.platform}::${crypto_1.default.randomBytes(16).toString('hex').toUpperCase()}`,
        });
        this.stream.enableKeepAlive({
            interval: this.client.config.xmppKeepAliveInterval,
        });
        this.setupEvents();
    }
    /**
     * Connects the XMPP agent to Epicgames' XMPP servers
     */
    async connect() {
        if (!this.stream)
            return { error: new Error('XMPP#stream is undefined. Please use XMPP#setup before calling XMPP#connect') };
        this.client.debug('[XMPP] Connecting...');
        const connectionStartTime = Date.now();
        return new Promise((res) => {
            var _a, _b, _c;
            const timeout = setTimeout(() => {
                res({ error: new Error('Timeout of 15000ms exceeded') });
            }, 15000);
            (_a = this.stream) === null || _a === void 0 ? void 0 : _a.once('session:started', () => {
                clearTimeout(timeout);
                this.connectedTimestamp = Date.now();
                this.client.debug(`[XMPP] Successfully connected (${((Date.now() - connectionStartTime) / 1000).toFixed(2)}s)`);
                this.sendStatus();
                res({ response: true });
            });
            (_b = this.stream) === null || _b === void 0 ? void 0 : _b.once('stream:error', (err) => {
                clearTimeout(timeout);
                res({ error: err });
            });
            (_c = this.stream) === null || _c === void 0 ? void 0 : _c.connect();
        });
    }
    /**
     * Disconnects the XMPP client.
     * Also performs a cleanup
     */
    async disconnect() {
        if (!this.isConnected)
            return { response: true };
        this.client.debug('[XMPP] Disconnecting...');
        const disconnectionStartTime = Date.now();
        return new Promise((res) => {
            var _a, _b;
            const timeout = this.client.setTimeout(() => {
                res({ error: new Error('Timeout of 15000ms exceeded') });
                this.isDisconnecting = false;
            }, 15000);
            (_a = this.stream) === null || _a === void 0 ? void 0 : _a.once('disconnected', () => {
                clearTimeout(timeout);
                this.connectedTimestamp = undefined;
                this.destroy();
                res({ response: true });
                this.client.debug(`[XMPP] Successfully disconnected (${((Date.now() - disconnectionStartTime) / 1000).toFixed(2)}s)`);
                this.isDisconnecting = false;
            });
            this.isDisconnecting = true;
            (_b = this.stream) === null || _b === void 0 ? void 0 : _b.disconnect();
        });
    }
    /**
     * Cleans everything up after the XMPP client disconnected
     */
    destroy() {
        var _a;
        (_a = this.stream) === null || _a === void 0 ? void 0 : _a.removeAllListeners();
        this.stream = undefined;
    }
    /**
     * Registers all events
     */
    setupEvents() {
        if (!this.stream)
            throw new Error('Cannot register events before stream was initialized');
        this.stream.on('disconnected', async () => {
            if (this.isDisconnecting)
                return;
            this.destroy();
            this.setup();
            await this.connect();
            if (this.client.config.fetchFriends)
                await this.client.updateCaches();
            await this.client.initParty(this.client.config.createParty, this.client.config.forceNewParty);
        });
        this.stream.on('raw:incoming', (raw) => this.client.debug(`IN ${raw}`, 'xmpp'));
        this.stream.on('raw:outgoing', (raw) => this.client.debug(`OUT ${raw}`, 'xmpp'));
        this.stream.on('groupchat', async (m) => {
            var _a;
            try {
                await this.client.partyLock.wait();
                const partyId = m.from.split('@')[0].replace('Party-', '');
                if (!this.client.party || this.client.party.id !== partyId)
                    return;
                if (m.body === 'Welcome! You created new Multi User Chat Room.')
                    return;
                const [, authorId] = m.from.split(':');
                if (authorId === ((_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id))
                    return;
                const authorMember = this.client.party.members.get(authorId);
                if (!authorMember)
                    return;
                const partyMessage = new PartyMessage_1.default(this.client, {
                    content: m.body || '', author: authorMember, sentAt: new Date(), id: m.id, party: this.client.party,
                });
                this.client.emit('party:member:message', partyMessage);
            }
            catch (err) {
                this.client.debug(`[XMPP] Error while processing party chat message: ${err.name} - ${err.message}`);
                this.client.emit('xmpp:chat:error', err);
            }
        });
        this.stream.on('chat', async (m) => {
            try {
                const friend = await this.waitForFriend(m.from.split('@')[0]);
                if (!friend)
                    return;
                const message = new ReceivedFriendMessage_1.default(this.client, {
                    content: m.body || '', author: friend, id: m.id, sentAt: new Date(),
                });
                this.client.emit('friend:message', message);
            }
            catch (err) {
                this.client.debug(`[XMPP] Error while processing friend whisper message: ${err.name} - ${err.message}`);
                this.client.emit('xmpp:chat:error', err);
            }
        });
        this.stream.on('presence', async (p) => {
            var _a, _b, _c, _d;
            try {
                await this.client.cacheLock.wait();
                if (!p.status)
                    return;
                const friendId = p.from.split('@')[0];
                if (friendId === ((_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id))
                    return;
                const friend = await this.waitForFriend(friendId);
                if (!friend)
                    return;
                if (p.type === 'unavailable') {
                    friend.lastAvailableTimestamp = undefined;
                    friend.party = undefined;
                    this.client.emit('friend:offline', friend);
                    return;
                }
                const wasUnavailable = !friend.lastAvailableTimestamp;
                friend.lastAvailableTimestamp = Date.now();
                const presence = JSON.parse(p.status);
                const before = (_b = this.client.friends.get(friendId)) === null || _b === void 0 ? void 0 : _b.presence;
                const after = new FriendPresence_1.default(this.client, presence, friend, p.show || 'online', p.from);
                if ((((_c = this.client.config.cacheSettings.presences) === null || _c === void 0 ? void 0 : _c.maxLifetime) || 0) > 0) {
                    friend.presence = after;
                }
                if ((_d = presence.Properties) === null || _d === void 0 ? void 0 : _d['party.joininfodata.286331153_j']) {
                    friend.party = new PresenceParty_1.default(this.client, presence.Properties['party.joininfodata.286331153_j']);
                }
                if (wasUnavailable && this.connectedTimestamp && this.connectedTimestamp > this.client.config.friendOnlineConnectionTimeout) {
                    this.client.emit('friend:online', friend);
                }
                this.client.emit('friend:presence', before, after);
            }
            catch (err) {
                this.client.debug(`[XMPP] Error while processing presence: ${err.name} - ${err.message}`);
                this.client.emit('xmpp:presence:error', err);
            }
        });
        this.stream.on('message', async (m) => {
            var _a, _b, _c, _d, _e, _f, _g;
            if (m.type && m.type !== 'normal')
                return;
            if (!m.body)
                return;
            if (m.from !== 'xmpp-admin@prod.ol.epicgames.com')
                return;
            let body;
            try {
                body = JSON.parse(m.body);
            }
            catch (err) {
                return;
            }
            if (!body.type)
                return;
            try {
                switch (body.type) {
                    case 'com.epicgames.friends.core.apiobjects.Friend':
                        {
                            const { payload: { status, accountId, favorite, created, direction, }, } = body;
                            const user = await this.client.getProfile(accountId);
                            if (!user)
                                break;
                            if (status === 'ACCEPTED') {
                                const friend = new Friend_1.default(this.client, {
                                    displayName: user.displayName,
                                    id: user.id,
                                    externalAuths: user.externalAuths,
                                    favorite,
                                    created,
                                    alias: '',
                                    note: '',
                                });
                                this.client.friends.set(friend.id, friend);
                                this.client.pendingFriends.delete(friend.id);
                                this.client.emit('friend:added', friend);
                            }
                            else if (status === 'PENDING') {
                                if (direction === 'INBOUND') {
                                    const pendingFriend = new IncomingPendingFriend_1.default(this.client, {
                                        accountId: user.id,
                                        // Type casting is fine here because the lookup by id always returns external auths
                                        displayName: user.displayName,
                                        created,
                                        favorite,
                                    });
                                    this.client.pendingFriends.set(pendingFriend.id, pendingFriend);
                                    this.client.emit('friend:request', pendingFriend);
                                }
                                else if (direction === 'OUTBOUND') {
                                    const pendingFriend = new OutgoingPendingFriend_1.default(this.client, {
                                        accountId: user.id,
                                        // Type casting is fine here because the lookup by id always returns external auths
                                        displayName: user.displayName,
                                        created,
                                        favorite,
                                    });
                                    this.client.pendingFriends.set(pendingFriend.id, pendingFriend);
                                    this.client.emit('friend:request:sent', pendingFriend);
                                }
                            }
                        }
                        break;
                    case 'FRIENDSHIP_REMOVE':
                        {
                            const { from, to, reason } = body;
                            const accountId = from === ((_a = this.client.user) === null || _a === void 0 ? void 0 : _a.id) ? to : from;
                            if (reason === 'ABORTED') {
                                const pendingFriend = this.client.pendingFriends.get(accountId);
                                if (!pendingFriend)
                                    break;
                                this.client.pendingFriends.delete(pendingFriend.id);
                                this.client.emit('friend:request:aborted', pendingFriend);
                            }
                            else if (reason === 'REJECTED') {
                                const pendingFriend = this.client.pendingFriends.get(accountId);
                                if (!pendingFriend)
                                    break;
                                this.client.pendingFriends.delete(pendingFriend.id);
                                this.client.emit('friend:request:declined', pendingFriend);
                            }
                            else if (reason === 'DELETED') {
                                const friend = await this.waitForFriend(accountId);
                                if (!friend)
                                    break;
                                this.client.friends.delete(friend.id);
                                this.client.emit('friend:removed', friend);
                            }
                        }
                        break;
                    case 'USER_BLOCKLIST_UPDATE':
                        {
                            const { status, accountId } = body;
                            if (status === 'BLOCKED') {
                                const user = await this.client.getProfile(accountId);
                                if (!user)
                                    break;
                                const blockedUser = new BlockedUser_1.default(this.client, user);
                                this.client.blockedUsers.set(user.id, blockedUser);
                                this.client.emit('user:blocked', blockedUser);
                            }
                            else if (status === 'UNBLOCKED') {
                                const blockedUser = this.client.blockedUsers.get(accountId);
                                if (!blockedUser)
                                    break;
                                this.client.blockedUsers.delete(blockedUser.id);
                                this.client.emit('user:unblocked', blockedUser);
                            }
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.PING':
                        {
                            if (this.client.listenerCount('party:invite') === 0)
                                break;
                            const pingerId = body.pinger_id;
                            const friend = await this.waitForFriend(pingerId);
                            if (!friend)
                                throw new FriendNotFoundError_1.default(pingerId);
                            const data = await this.client.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_PARTY}/user/${(_b = this.client.user) === null || _b === void 0 ? void 0 : _b.id}/pings/${pingerId}/parties`, 'fortnite');
                            if (data.error)
                                throw data.error;
                            if (!((_c = data.response) === null || _c === void 0 ? void 0 : _c[0])) {
                                this.client.debug(`[XMPP] Error while processing ${body.type}: Could't find an active invitation`);
                                break;
                            }
                            const [partyData] = data.response;
                            let party;
                            if (partyData.config.discoverability === 'ALL')
                                party = await this.client.getParty(partyData.id);
                            else
                                party = new Party_1.default(this.client, partyData);
                            if (party.members.some((pm) => !pm.displayName))
                                await party.updateMemberBasicInfo();
                            let invitation = partyData.invites.find((i) => i.sent_by === pingerId && i.status === 'SENT');
                            if (!invitation)
                                invitation = (0, Util_1.createPartyInvitation)(this.client.user.id, pingerId, { ...body, ...partyData });
                            const invite = new ReceivedPartyInvitation_1.default(this.client, party, friend, this.client.user, invitation);
                            this.client.emit('party:invite', invite);
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.MEMBER_JOINED':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id)
                                break;
                            const memberId = body.account_id;
                            if (memberId === ((_d = this.client.user) === null || _d === void 0 ? void 0 : _d.id)) {
                                if (!this.client.party.me)
                                    this.client.party.members.set(memberId, new ClientPartyMember_1.default(this.client.party, body));
                                await this.client.party.me.sendPatch(this.client.party.me.meta.schema);
                            }
                            else {
                                this.client.party.members.set(memberId, new PartyMember_1.default(this.client.party, body));
                            }
                            const member = this.client.party.members.get(memberId);
                            if (!member)
                                break;
                            if (!member.displayName)
                                await member.fetch();
                            this.client.setStatus();
                            if (this.client.party.me.isLeader)
                                await this.client.party.refreshSquadAssignments();
                            try {
                                await this.client.waitForEvent('party:member:updated', 2000, (um) => um.id === member.id);
                            }
                            catch (err) {
                                // ignore. meta will be partly undefined, but usually, if this takes longer than 2 seconds, something else went wrong
                            }
                            this.client.emit('party:member:joined', member);
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.MEMBER_STATE_UPDATED':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id)
                                return;
                            const memberId = body.account_id;
                            const member = this.client.party.members.get(memberId);
                            if (!member)
                                throw new PartyMemberNotFoundError_1.default(memberId);
                            if (member.receivedInitialStateUpdate) {
                                const newMeta = new PartyMemberMeta_1.default({ ...member.meta.schema });
                                newMeta.update(body.member_state_updated, true);
                                if (newMeta.outfit !== member.meta.outfit)
                                    this.client.emit('party:member:outfit:updated', member, newMeta.outfit, member.meta.outfit);
                                if (newMeta.backpack !== member.meta.backpack)
                                    this.client.emit('party:member:backpack:updated', member, newMeta.backpack, member.meta.backpack);
                                if (newMeta.pickaxe !== member.meta.pickaxe)
                                    this.client.emit('party:member:pickaxe:updated', member, newMeta.pickaxe, member.meta.pickaxe);
                                if (newMeta.emote !== member.meta.emote)
                                    this.client.emit('party:member:emote:updated', member, newMeta.emote, member.meta.emote);
                                if (newMeta.isReady !== member.meta.isReady)
                                    this.client.emit('party:member:readiness:updated', member, newMeta.isReady, member.meta.isReady);
                                if (JSON.stringify(newMeta.match) !== JSON.stringify(member.meta.match)) {
                                    this.client.emit('party:member:matchstate:updated', member, newMeta.match, member.meta.match);
                                }
                            }
                            member.updateData(body);
                            member.receivedInitialStateUpdate = true;
                            this.client.emit('party:member:updated', member);
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.MEMBER_LEFT':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id)
                                break;
                            const memberId = body.account_id;
                            const member = this.client.party.members.get(memberId);
                            if (!member) {
                                if (this.client.party.pendingMemberConfirmations.has(memberId)) {
                                    this.client.party.pendingMemberConfirmations.delete(memberId);
                                    break;
                                }
                                throw new PartyMemberNotFoundError_1.default(memberId);
                            }
                            if (memberId === ((_e = this.client.user) === null || _e === void 0 ? void 0 : _e.id)) {
                                await this.client.initParty(true, false);
                                break;
                            }
                            this.client.party.members.delete(member.id);
                            this.client.setStatus();
                            if (this.client.party.me.isLeader)
                                await this.client.party.refreshSquadAssignments();
                            this.client.emit('party:member:left', member);
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.MEMBER_EXPIRED':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id
                                || body.account_id === ((_f = this.client.user) === null || _f === void 0 ? void 0 : _f.id))
                                break;
                            const memberId = body.account_id;
                            const member = this.client.party.members.get(memberId);
                            if (!member)
                                return;
                            this.client.party.members.delete(member.id);
                            this.client.setStatus();
                            if (this.client.party.me.isLeader)
                                await this.client.party.refreshSquadAssignments();
                            this.client.emit('party:member:expired', member);
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.MEMBER_KICKED':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id)
                                break;
                            const memberId = body.account_id;
                            const member = this.client.party.members.get(memberId);
                            if (!member)
                                throw new PartyMemberNotFoundError_1.default(memberId);
                            if (member.id === ((_g = this.client.user) === null || _g === void 0 ? void 0 : _g.id)) {
                                this.client.party = undefined;
                                await this.client.initParty(true, false);
                            }
                            else {
                                this.client.party.members.delete(member.id);
                                this.client.setStatus();
                                if (this.client.party.me.isLeader)
                                    await this.client.party.refreshSquadAssignments();
                            }
                            this.client.emit('party:member:kicked', member);
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.MEMBER_DISCONNECTED':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id)
                                break;
                            const memberId = body.account_id;
                            const member = this.client.party.members.get(memberId);
                            if (!member)
                                throw new PartyMemberNotFoundError_1.default(memberId);
                            this.client.party.members.delete(member.id);
                            this.client.setStatus();
                            if (this.client.party.me.isLeader)
                                await this.client.party.refreshSquadAssignments();
                            this.client.emit('party:member:disconnected', member);
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.MEMBER_NEW_CAPTAIN':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id)
                                break;
                            if (this.client.party.leader)
                                this.client.party.leader.role = '';
                            const memberId = body.account_id;
                            const member = this.client.party.members.get(memberId);
                            if (!member)
                                throw new PartyMemberNotFoundError_1.default(memberId);
                            member.role = 'CAPTAIN';
                            this.client.setStatus();
                            this.client.emit('party:member:promoted', member);
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.PARTY_UPDATED':
                        await this.client.partyLock.wait();
                        if (!this.client.party || this.client.party.id !== body.party_id)
                            break;
                        this.client.party.updateData(body);
                        this.client.setStatus();
                        this.client.emit('party:updated', this.client.party);
                        break;
                    case 'com.epicgames.social.party.notification.v0.MEMBER_REQUIRE_CONFIRMATION':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id)
                                break;
                            const user = await this.client.getProfile(body.account_id);
                            if (!user)
                                break;
                            const confirmation = new PartyMemberConfirmation_1.default(this.client, this.client.party, user, body);
                            this.client.party.pendingMemberConfirmations.set(user.id, confirmation);
                            if (this.client.listenerCount('party:member:confirmation') > 0) {
                                this.client.emit('party:member:confirmation', confirmation);
                            }
                            else {
                                await confirmation.confirm();
                            }
                        }
                        break;
                    case 'com.epicgames.social.party.notification.v0.INITIAL_INTENTION':
                        {
                            await this.client.partyLock.wait();
                            if (!this.client.party || this.client.party.id !== body.party_id)
                                break;
                            const friend = await this.waitForFriend(body.requester_id);
                            if (!friend)
                                throw new FriendNotFoundError_1.default(body.requester_id);
                            const request = new ReceivedPartyJoinRequest_1.default(this.client, friend, this.client.user, body);
                            this.client.emit('party:joinrequest', request);
                        }
                        break;
                }
            }
            catch (err) {
                this.client.debug(`[XMPP] Error while processing ${body.type}: ${err.name} - ${err.message}`);
                this.client.emit('xmpp:message:error', err);
            }
        });
    }
    /**
     * Waits for a friend to be added to the clients cache
     */
    async waitForFriend(id) {
        const cachedFriend = this.client.friends.get(id);
        if (cachedFriend)
            return cachedFriend;
        try {
            this.client.setMaxListeners(this.client.getMaxListeners() + 1);
            const friend = await this.client.waitForEvent('friend:added', 5000, (f) => f.id === id);
            return friend[0];
        }
        catch (e) {
            return undefined;
        }
        finally {
            this.client.setMaxListeners(this.client.getMaxListeners() - 1);
        }
    }
    /**
     * Sends a presence to all or a specific friend
     * @param status The status message. Can be undefined if you want to reset it
     * @param show The show type of the presence (eg "away")
     * @param to The JID of a specific friend
     */
    sendStatus(status, show, to) {
        var _a, _b;
        if (!status) {
            (_a = this.stream) === null || _a === void 0 ? void 0 : _a.sendPresence();
            return;
        }
        (_b = this.stream) === null || _b === void 0 ? void 0 : _b.sendPresence({
            status: JSON.stringify(typeof status === 'string' ? { Status: status } : status),
            to,
            show,
        });
    }
    /**
     * Sends an XMPP message
     * @param to The message receiver's JID
     * @param content The message that will be sent
     * @param type The message type (eg "chat" or "groupchat")
     */
    async sendMessage(to, content, type = 'chat') {
        var _a;
        if (!this.stream)
            return undefined;
        return this.waitForSentMessage((_a = this.stream) === null || _a === void 0 ? void 0 : _a.sendMessage({
            to,
            body: content,
            type,
        }));
    }
    /**
     * Wait until a message is sent
     * @param id The message id
     * @param timeout How long to wait for the message
     */
    waitForSentMessage(id, timeout = 1000) {
        return new Promise((res) => {
            var _a;
            // eslint-disable-next-line no-undef
            let messageTimeout;
            const listener = (m) => {
                var _a;
                if (m.id === id) {
                    (_a = this.stream) === null || _a === void 0 ? void 0 : _a.removeListener('message:sent', listener);
                    if (messageTimeout)
                        clearTimeout(messageTimeout);
                    res(m);
                }
            };
            (_a = this.stream) === null || _a === void 0 ? void 0 : _a.on('message:sent', listener);
            messageTimeout = setTimeout(() => {
                var _a;
                res(undefined);
                (_a = this.stream) === null || _a === void 0 ? void 0 : _a.removeListener('message:sent', listener);
            }, timeout);
        });
    }
    /**
     * Joins a multi user chat room (MUC)
     * @param jid The room's JID
     * @param nick The client's nickname
     */
    async joinMUC(jid, nick) {
        var _a;
        return (_a = this.stream) === null || _a === void 0 ? void 0 : _a.joinRoom(jid, nick);
    }
    /**
     * Leaves a multi user chat room (MUC)
     * @param jid The room's JID
     * @param nick The client's nickname
     */
    async leaveMUC(jid, nick) {
        var _a;
        return (_a = this.stream) === null || _a === void 0 ? void 0 : _a.leaveRoom(jid, nick);
    }
}
exports.default = XMPP;
//# sourceMappingURL=XMPP.js.map