/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import { Collection } from '@discordjs/collection';
import Auth from './Auth';
import Http from './HTTP';
import AsyncLock from '../util/AsyncLock';
import { ClientOptions, ClientConfig, ClientEvents, PartyConfig, Schema, PresenceOnlineType, Region, FullPlatform, UserSearchPlatform, BlurlStream, ReplayDownloadOptions, TournamentSessionMetadata, STWWorldInfoData, BRAccountLevelData, Language, PartyData } from '../../resources/structs';
import ClientUser from '../structures/user/ClientUser';
import XMPP from './XMPP';
import Friend from '../structures/friend/Friend';
import User from '../structures/user/User';
import { CreativeIslandData, CreativeDiscoveryPanel, TournamentWindowResults } from '../../resources/httpResponses';
import CreatorCode from '../structures/CreatorCode';
import IncomingPendingFriend from '../structures/friend/IncomingPendingFriend';
import OutgoingPendingFriend from '../structures/friend/OutgoingPendingFriend';
import BlockedUser from '../structures/user/BlockedUser';
import ClientParty from '../structures/party/ClientParty';
import Party from '../structures/party/Party';
import Tournament from '../structures/Tournament';
import SentPartyJoinRequest from '../structures/party/SentPartyJoinRequest';
import UserSearchResult from '../structures/user/UserSearchResult';
import RadioStation from '../structures/RadioStation';
import SentFriendMessage from '../structures/friend/SentFriendMessage';
import Avatar from '../structures/Avatar';
import GlobalProfile from '../structures/GlobalProfile';
import STWProfile from '../structures/stw/STWProfile';
import Stats from '../structures/Stats';
import NewsMessage from '../structures/NewsMessage';
import STWNewsMessage from '../structures/stw/STWNewsMessage';
import EventTokens from '../structures/EventTokens';
import FortniteServerStatus from '../structures/FortniteServerStatus';
import EpicgamesServerStatus from '../structures/EpicgamesServerStatus';
/**
 * Represets the main client
 */
declare class Client extends EventEmitter {
    /**
     * Timeouts set by {@link Client#setTimeout} that are still active
     */
    private timeouts;
    /**
     * Intervals set by {@link Client#setInterval} that are still active
     */
    private intervals;
    /**
     * All client configuration options
     */
    config: ClientConfig;
    /**
     * Authentication manager
     */
    auth: Auth;
    /**
     * Lock used to pause all http requests while the client is reauthenticating
     */
    reauthLock: AsyncLock;
    /**
     * Lock used to pause certain incoming xmpp messages while the bots party is being modified
     */
    partyLock: AsyncLock;
    /**
     * Lock used to pause xmpp presences while the friend caches are being populated
     */
    cacheLock: AsyncLock;
    /**
     * HTTP manager
     */
    http: Http;
    /**
     * Epicgames account of the client
     */
    user?: ClientUser;
    /**
     * Whether the client is fully started
     */
    isReady: boolean;
    /**
     * XMPP manager
     */
    xmpp: XMPP;
    /**
     * Friend list
     */
    friends: Collection<string, Friend>;
    /**
     * Pending friend requests (incoming or outgoing)
     */
    pendingFriends: Collection<string, IncomingPendingFriend | OutgoingPendingFriend>;
    /**
     * User blocklist
     */
    blockedUsers: Collection<string, BlockedUser>;
    /**
     * The client's current party
     */
    party?: ClientParty;
    /**
     * The last saved client party member meta
     */
    lastPartyMemberMeta?: Schema;
    /**
     * @param config The client's configuration options
     */
    constructor(config?: ClientOptions);
    on<U extends keyof ClientEvents>(event: U, listener: ClientEvents[U]): this;
    once<U extends keyof ClientEvents>(event: U, listener: ClientEvents[U]): this;
    emit<U extends keyof ClientEvents>(event: U, ...args: Parameters<ClientEvents[U]>): boolean;
    /**
     * Logs the client in.
     * A valid authentication method must be provided in the client's config.
     * By default, there will be a console prompt asking for an authorization code
     * @throws {EpicgamesAPIError}
     * @throws {EpicgamesGraphQLError}
     */
    login(): Promise<void>;
    /**
     * Logs the client out.
     * Also clears all caches, etc
     */
    logout(): Promise<void>;
    /**
     * Restarts the client
     */
    restart(): Promise<void>;
    /**
     * Initializes {@link Client#party}
     * @param createNew Whether to create a new party
     * @param forceNew Whether to force create a new party
     */
    initParty(createNew?: boolean, forceNew?: boolean): Promise<void>;
    /**
     * Internal method that sets a {@link ClientParty} to the value of {@link Client#party}
     * @param party The party
     * @private
     */
    setClientParty(party: Party): void;
    /**
     * Waits until the client is ready
     * @param timeout How long to wait for until an error is thrown
     */
    waitUntilReady(timeout?: number): Promise<void>;
    /**
     * Cleanup method
     */
    private destroy;
    /**
     * Initializes the sweeping of cached objects
     */
    private initCacheSweeping;
    /**
     * Updates the client's caches
     */
    updateCaches(): Promise<void>;
    /**
     * Removes presences from the clients cache that are older than the max lifetime
     * @param maxLifetime How old a presence must be before it can be sweeped (in seconds)
     * @returns The amount of presences sweeped
     */
    sweepPresences(maxLifetime?: number | undefined): number;
    /**
     * Wait until an event is emitted
     * @param event The event that will be waited for
     * @param timeout The timeout (in milliseconds)
     * @param filter The filter for the event
     */
    waitForEvent<U extends keyof ClientEvents>(event: U, timeout?: number, filter?: (...args: Parameters<ClientEvents[U]>) => boolean): Promise<Parameters<ClientEvents[U]>>;
    /**
     * Sets a timeout that will be automatically cancelled if the client is logged out
     * @param fn Function to execute
     * @param delay Time to wait before executing (in milliseconds)
     * @param args Arguments for the function
     */
    setTimeout(fn: (...args: any) => any, delay: number, ...args: any): NodeJS.Timeout;
    /**
     * Clears a timeout
     * @param timeout Timeout to cancel
     */
    clearTimeout(timeout: NodeJS.Timeout): void;
    /**
     * Sets an interval that will be automatically cancelled if the client is logged out
     * @param fn Function to execute
     * @param delay Time to wait between executions (in milliseconds)
     * @param args Arguments for the function
     */
    setInterval(fn: (...args: any) => any, delay: number, ...args: any): NodeJS.Timer;
    /**
     * Clears an interval.
     * @param interval Interval to cancel
     */
    clearInterval(interval: NodeJS.Timeout): void;
    static consoleQuestion(question: string): Promise<string>;
    /**
     * Debug a message using the methods set in the client config
     * @param message Text to debug
     * @param type Debug type (regular, http or xmpp)
     */
    debug(message: string, type?: 'regular' | 'http' | 'xmpp'): void;
    getProfile(query: string): Promise<User | undefined>;
    getProfile(query: string[]): Promise<User[]>;
    /**
     * Fetches users that match a prefix
     * @param prefix The prefix (a string that the user's display names start with)
     * @param platform The search platform. Other platform's accounts will still be searched with a lower priority
     */
    searchProfiles(prefix: string, platform?: UserSearchPlatform): Promise<UserSearchResult[]>;
    /**
     * Resolves a single user id
     * @param query Display name or id of the account's id to resolve
     */
    private resolveUserId;
    /**
     * Sets the clients XMPP status
     * @param status The status
     * @param onlineType The presence's online type (eg "away")
     * @param friend A specific friend you want to send this status to
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     */
    setStatus(status?: string, onlineType?: PresenceOnlineType, friend?: string): void;
    /**
     * Resets the client's XMPP status and online type
     */
    resetStatus(): Promise<void>;
    /**
     * Sends a friendship request to a user or accepts an existing request
     * @param friend The id or display name of the user to add
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {DuplicateFriendshipError} The user is already friends with the client
     * @throws {FriendshipRequestAlreadySentError} A friendship request has already been sent to the user
     * @throws {InviterFriendshipsLimitExceededError} The client's friendship limit is reached
     * @throws {InviteeFriendshipsLimitExceededError} The user's friendship limit is reached
     * @throws {InviteeFriendshipSettingsError} The user disabled friend requests
     * @throws {InviteeFriendshipRequestLimitExceededError} The user's incoming friend request limit is reached
     * @throws {EpicgamesAPIError}
     */
    addFriend(friend: string): Promise<void>;
    /**
     * Removes a friend from the client's friend list or declines / aborts a pending friendship request
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    removeFriend(friend: string): Promise<void>;
    /**
     * Fetches the friends the client shares with a friend
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    getMutualFriends(friend: string): Promise<Friend[]>;
    /**
     * Checks whether a friend owns a specific offer
     * @param friend The id or display name of the friend
     * @param offerId The offer id
     * @throws {OfferNotFoundError} The offer does not exist or is not in the current storefront catalog
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    checkFriendOfferOwnership(friend: string, offerId: string): Promise<boolean>;
    /**
     * Blocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    blockUser(user: string): Promise<void>;
    /**
     * Unblocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    unblockUser(user: string): Promise<void>;
    /**
     * Sends a message to a friend
     * @param friend The id or display name of the friend
     * @param content The message that will be sent
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {SendMessageError} The messant could not be sent
     */
    sendFriendMessage(friend: string, content: string): Promise<SentFriendMessage>;
    /**
     * Sends a party invitation to a friend
     * @param friend The friend that will receive the invitation
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {PartyAlreadyJoinedError} The user is already a member of this party
     * @throws {PartyMaxSizeReachedError} The party reached its max size
     * @throws {PartyNotFoundError} The client is not in party
     * @throws {EpicgamesAPIError}
     */
    invite(friend: string): Promise<import("../structures/party/SentPartyInvitation").default>;
    /**
     * Joins a party by its id
     * @param id The party id
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched
     * @throws {PartyMaxSizeReachedError} The party has reached its max size
     * @throws {EpicgamesAPIError}
     */
    joinParty(id: string): Promise<void>;
    /**
     * Creates a new party
     * @param config The party config
     * @throws {EpicgamesAPIError}
     */
    createParty(config?: PartyConfig): Promise<void>;
    /**
     * Leaves the client's current party
     * @param createNew Whether a new party should be created
     * @throws {EpicgamesAPIError}
     */
    leaveParty(createNew?: boolean): Promise<void>;
    /**
     * Sends a party join request to a friend.
     * When the friend confirms this, a party invite will be sent to the client
     * @param friend The friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {PartyNotFoundError} The friend is not in a party
     * @throws {EpicgamesAPIError}
     */
    sendRequestToJoin(friend: string): Promise<SentPartyJoinRequest>;
    /**
     * Fetches the client's party
     * @throws {EpicgamesAPIError}
     */
    getClientParty(): Promise<ClientParty | undefined>;
    /**
     * Fetches a party by its id
     * @param id The party's id
     * @param raw Whether to return the raw party data
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched due to a permission error
     * @throws {EpicgamesAPIError}
     */
    getParty(id: string, raw?: boolean): Promise<Party | PartyData>;
    /**
     * Fetches the current Fortnite server status (lightswitch)
     * @throws {EpicgamesAPIError}
     */
    getFortniteServerStatus(): Promise<FortniteServerStatus>;
    /**
     * Fetches the current epicgames server status (https://status.epicgames.com/)
     * @throws {AxiosError}
     */
    getEpicgamesServerStatus(): Promise<EpicgamesServerStatus>;
    /**
     * Fetches the current Fortnite storefronts
     * @param language The language
     * @throws {EpicgamesAPIError}
     */
    getStorefronts(language?: Language): Promise<any>;
    /**
     * Downloads a blurl stream (eg a radio station stream or a news video)
     * @param id The stream ID
     * @throws {AxiosError}
     */
    downloadBlurlStream(id: string): Promise<BlurlStream>;
    /**
     * Fetches the avatar for one or more users
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {EpicgamesAPIError}
     */
    getUserAvatar(user: string | string[]): Promise<Avatar[]>;
    /**
     * Fetches the global profile for one or more users
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {EpicgamesAPIError}
     */
    getGlobalProfile(user: string | string[]): Promise<GlobalProfile[]>;
    getBRStats(user: string, startTime?: number, endTime?: number): Promise<Stats>;
    getBRStats(user: string[], startTime?: number, endTime?: number, stats?: string[]): Promise<Stats[]>;
    /**
     * Fetches the current Battle Royale news
     * @param language The language of the news
     * @param customPayload Extra data to send in the request body for a personalized news response (battle pass level, country, etc)
     * @throws {EpicgamesAPIError}
     */
    getBRNews(language: string | undefined, customPayload: any): Promise<NewsMessage[]>;
    /**
     * Fetches data for a Support-A-Creator code
     * @param code The Support-A-Creator code (slug)
     * @throws {CreatorCodeNotFoundError} The Support-A-Creator code wasnt found
     * @throws {EpicgamesAPIError}
     */
    getCreatorCode(code: string): Promise<CreatorCode>;
    /**
     * Fetches the current Fortnite Battle Royale radio stations
     * @throws {EpicgamesAPIError}
     */
    getRadioStations(): Promise<RadioStation[]>;
    /**
     * Fetches the current Battle Royale event flags
     * @param language The language
     * @throws {EpicgamesAPIError}
     */
    getBREventFlags(language?: Language): Promise<any>;
    /**
     * Fetches the Battle Royale account level for one or multiple users
     * @param user The id(s) and/or display name(s) of the user(s) to fetch the account level for
     * @param seasonNumber The season number (eg. 16, 17, 18)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {StatsPrivacyError} The user set their stats to private
     * @throws {EpicgamesAPIError}
     */
    getBRAccountLevel(user: string | string[], seasonNumber: number): Promise<BRAccountLevelData[]>;
    /**
     * Fetches the storefront keychain
     * @throws {EpicgamesAPIError}
     */
    getStorefrontKeychain(): Promise<string[]>;
    /**
     * Fetches the event tokens for an account.
     * This can be used to check if a user is eligible to play a certain tournament window
     * or to check a user's arena division in any season
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    getEventTokens(user: string | string[]): Promise<EventTokens[]>;
    /**
     * Fetches the current and past Battle Royale tournaments
     * @param region The region
     * @param platform The platform
     * @throws {EpicgamesAPIError}
     */
    getTournaments(region?: Region, platform?: FullPlatform): Promise<Tournament[]>;
    /**
     * Fetches the results for a tournament window
     * @param eventId The tournament's ID
     * @param eventWindowId The tournament window's ID
     * @param showLiveSessions Whether to show live sessions
     * @param page The results page index
     * @throws {EpicgamesAPIError}
     */
    getTournamentWindowResults(eventId: string, eventWindowId: string, showLiveSessions?: boolean, page?: number): Promise<TournamentWindowResults>;
    /**
     * Downloads a tournament replay by its session ID.
     * This method returns a regular Fortnite replay file, can be parsed using https://github.com/ThisNils/node-replay-reader
     * @param sessionId The session ID
     * @param options Replay download and build options
     * @throws {MatchNotFoundError} The match wasn't found
     * @throws {EpicgamesAPIError}
     * @throws {AxiosError}
     */
    downloadTournamentReplay(sessionId: string, options: ReplayDownloadOptions): Promise<Buffer>;
    /**
     * Fetches a tournament session's metadata
     * @param sessionId The session ID
     * @throws {MatchNotFoundError} The match wasn't found
     * @throws {EpicgamesAPIError}
     * @throws {AxiosError}
     */
    getTournamentSessionMetadata(sessionId: string): Promise<TournamentSessionMetadata>;
    /**
     * Downloads a file from the CDN (used for replays)
     * @param url The URL of the file to download
     * @param responseType The response type
     */
    private downloadReplayCDNFile;
    /**
     * Fetches a creative island by its code
     * @param code The island code
     * @throws {CreativeIslandNotFoundError} A creative island with the provided code does not exist
     * @throws {EpicgamesAPIError}
     */
    getCreativeIsland(code: string): Promise<CreativeIslandData>;
    /**
     * Fetches the creative discovery surface
     * @param gameVersion The current game version (MAJOR.MINOR)
     * @throws {EpicgamesAPIError}
     */
    getCreativeDiscoveryPanels(gameVersion: string | undefined, region: Region): Promise<CreativeDiscoveryPanel[]>;
    /**
     * Fetches the Save The World profile for a players
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    getSTWProfile(user: string): Promise<STWProfile>;
    /**
     * Fetches the current Save The World news
     * @param language The language of the news
     * @throws {EpicgamesAPIError}
     */
    getSTWNews(language?: Language): Promise<STWNewsMessage[]>;
    /**
     * Fetches the current Save The World world info
     * @param language The language of the world info
     * @throws {EpicgamesAPIError}
     */
    getSTWWorldInfo(language?: Language): Promise<STWWorldInfoData>;
}
export default Client;
