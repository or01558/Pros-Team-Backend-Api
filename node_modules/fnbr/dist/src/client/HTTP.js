"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable no-restricted-syntax */
const axios_1 = tslib_1.__importDefault(require("axios"));
const url_1 = require("url");
const EpicgamesAPIError_1 = tslib_1.__importDefault(require("../exceptions/EpicgamesAPIError"));
const EpicgamesGraphQLError_1 = tslib_1.__importDefault(require("../exceptions/EpicgamesGraphQLError"));
const Base_1 = tslib_1.__importDefault(require("./Base"));
/**
 * Represents the client's HTTP manager
 * @private
 */
class HTTP extends Base_1.default {
    /**
     * @param {Client} client The main client
     */
    constructor(client) {
        super(client);
        this.options = {
            ...this.client.config.http,
        };
        this.axios = axios_1.default.create(this.options);
        // Clear all default content type headers
        Object.keys(this.axios.defaults.headers).forEach((h) => {
            var _a;
            (_a = this.axios.defaults.headers[h]) === null || _a === void 0 ? true : delete _a['Content-Type'];
        });
    }
    /**
     * Sends a HTTP request
     * @param method The HTTP method
     * @param url The uri
     * @param headers The headers
     * @param body The body
     * @param form The form
     * @param responseType The axios response type
     * @param retries How many times this request has been retried
     */
    async send(method, url, headers = {}, body, form, responseType, retries = 0) {
        var _a, _b, _c, _d, _e;
        let data;
        if (body)
            data = body;
        else if (form) {
            const urlSearchParams = new url_1.URLSearchParams();
            for (const key of Object.keys(form)) {
                urlSearchParams.append(key, form[key]);
            }
            data = urlSearchParams;
        }
        const finalHeaders = headers;
        if (!finalHeaders['Accept-Language'])
            finalHeaders['Accept-Language'] = this.client.config.language;
        const reqStartTime = Date.now();
        try {
            const response = await this.axios.request({
                method,
                url,
                headers: finalHeaders,
                data,
                responseType,
            });
            this.client.debug(`${method} ${url} (${((Date.now() - reqStartTime) / 1000).toFixed(2)}s): `
                + `${response.status} ${response.statusText || '???'}`, 'http');
            return { response };
        }
        catch (err) {
            this.client.debug(`${method} ${url} (${((Date.now() - reqStartTime) / 1000).toFixed(2)}s): `
                + `${((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) || '???'} ${((_b = err.response) === null || _b === void 0 ? void 0 : _b.statusText) || '???'}`, 'http');
            const errResponse = err.response;
            const errResponseData = errResponse === null || errResponse === void 0 ? void 0 : errResponse.data;
            if ((errResponse === null || errResponse === void 0 ? void 0 : errResponse.status.toString().startsWith('5')) && retries < this.client.config.restRetryLimit) {
                return this.send(method, url, headers, body, form, responseType, retries + 1);
            }
            if (errResponse && (errResponse.status === 429 || (errResponseData === null || errResponseData === void 0 ? void 0 : errResponseData.errorCode) === 'errors.com.epicgames.common.throttled')) {
                const retryString = errResponse.headers['retry-after']
                    || ((_c = errResponseData === null || errResponseData === void 0 ? void 0 : errResponseData.messageVars) === null || _c === void 0 ? void 0 : _c[0])
                    || ((_e = (_d = errResponseData === null || errResponseData === void 0 ? void 0 : errResponseData.errorMessage) === null || _d === void 0 ? void 0 : _d.match(/(?<=in )\d+(?= second)/)) === null || _e === void 0 ? void 0 : _e[0]);
                const retryAfter = parseInt(retryString, 10);
                if (!Number.isNaN(retryAfter)) {
                    const sleepTimeout = (retryAfter * 1000) + 500;
                    await new Promise((res) => {
                        setTimeout(res, sleepTimeout);
                    });
                    return this.send(method, url, headers, body, form, responseType);
                }
            }
            return { error: err };
        }
    }
    /**
     * Sends a HTTP request to the Epicgames API
     * @param checkToken Whether the access token should be validated
     * @param method The HTTP method
     * @param url The uri
     * @param auth The auth type (eg. "fortnite" or "clientcreds")
     * @param headers The headers
     * @param data The body
     * @param form The form
     * @param ignoreLocks Where the request should ignore locks such as the reauth lock
     */
    async sendEpicgamesRequest(checkToken, method, url, auth, headers = {}, data, form, ignoreLocks = false) {
        var _a, _b, _c, _d, _e;
        if (!ignoreLocks)
            await this.client.reauthLock.wait();
        const finalHeaders = headers;
        if (auth) {
            let authData = this.client.auth.auths.get(auth);
            if (authData && checkToken) {
                const tokenCheck = await this.client.auth.checkToken(auth);
                if (!tokenCheck) {
                    const reauth = await this.client.auth.reauthenticate();
                    if (reauth.error)
                        return reauth;
                    authData = this.client.auth.auths.get(auth);
                }
            }
            finalHeaders.Authorization = `bearer ${authData === null || authData === void 0 ? void 0 : authData.token}`;
        }
        const request = await this.send(method, url, finalHeaders, data, form);
        if (['errors.com.epicgames.common.oauth.invalid_token', 'errors.com.epicgames.common.authentication.token_verification_failed']
            .includes((_c = (_b = (_a = request.error) === null || _a === void 0 ? void 0 : _a.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.errorCode) && auth) {
            const authData = this.client.auth.auths.get(auth);
            if (authData) {
                const reauth = await this.client.auth.reauthenticate();
                if (reauth.error)
                    return reauth;
                return this.sendEpicgamesRequest(checkToken, method, url, auth, headers, data, form, ignoreLocks);
            }
        }
        return {
            response: (_d = request.response) === null || _d === void 0 ? void 0 : _d.data,
            error: request.error && request.error.response
                && new EpicgamesAPIError_1.default((_e = request.error.response) === null || _e === void 0 ? void 0 : _e.data, request.error.config, request.error.response.status),
        };
    }
    /**
     * Sends a HTTP request to the Epicgames GraphQL API
     * @param checkToken Whether the access token should be validated
     * @param url The uri
     * @param query The GraphQL query string
     * @param variables The GraphQL variables
     * @param auth The auth type (eg. "fortnite" or "clientcreds")
     * @param operationName The GraphQL operation name (optional, will be auto set)
     * @param ignoreLocks Where the request should ignore locks such as the reauth lock
     */
    async sendEpicgamesGraphQLRequest(checkToken, url, query, variables = {}, auth, operationName, ignoreLocks = false) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!ignoreLocks)
            await this.client.reauthLock.wait();
        const headers = {
            'Content-Type': 'application/json',
        };
        if (auth) {
            let authData = this.client.auth.auths.get(auth);
            if (authData && checkToken) {
                const tokenCheck = await this.client.auth.checkToken(auth);
                if (!tokenCheck) {
                    const reauth = await this.client.auth.reauthenticate();
                    if (reauth.error)
                        return reauth;
                    authData = this.client.auth.auths.get(auth);
                }
            }
            headers.Authorization = `bearer ${authData === null || authData === void 0 ? void 0 : authData.token}`;
        }
        const finalOperationName = operationName || ((_a = query.match(/((?<=mutation )|(?<=query ))\w+/)) === null || _a === void 0 ? void 0 : _a[0]);
        const request = await this.send('POST', url, headers, {
            operationName: finalOperationName,
            variables,
            query,
        });
        const response = request;
        if ((_d = (_c = (_b = request.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.errors) === null || _d === void 0 ? void 0 : _d[0]) {
            response.error = new EpicgamesGraphQLError_1.default((_f = (_e = request.response) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.errors[0], request.response.config);
            request.response = undefined;
        }
        return {
            response: (_g = response.response) === null || _g === void 0 ? void 0 : _g.data,
            error: response.error,
        };
    }
}
exports.default = HTTP;
//# sourceMappingURL=HTTP.js.map