"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* eslint-disable no-restricted-syntax */
const events_1 = require("events");
const collection_1 = require("@discordjs/collection");
const Enums_1 = tslib_1.__importDefault(require("../../enums/Enums"));
const Util_1 = require("../util/Util");
const Auth_1 = tslib_1.__importDefault(require("./Auth"));
const HTTP_1 = tslib_1.__importDefault(require("./HTTP"));
const AsyncLock_1 = tslib_1.__importDefault(require("../util/AsyncLock"));
const Endpoints_1 = tslib_1.__importDefault(require("../../resources/Endpoints"));
const ClientUser_1 = tslib_1.__importDefault(require("../structures/user/ClientUser"));
const XMPP_1 = tslib_1.__importDefault(require("./XMPP"));
const Friend_1 = tslib_1.__importDefault(require("../structures/friend/Friend"));
const User_1 = tslib_1.__importDefault(require("../structures/user/User"));
const UserNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/UserNotFoundError"));
const StatsPrivacyError_1 = tslib_1.__importDefault(require("../exceptions/StatsPrivacyError"));
const CreatorCode_1 = tslib_1.__importDefault(require("../structures/CreatorCode"));
const CreatorCodeNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/CreatorCodeNotFoundError"));
const FriendNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/FriendNotFoundError"));
const DuplicateFriendshipError_1 = tslib_1.__importDefault(require("../exceptions/DuplicateFriendshipError"));
const FriendshipRequestAlreadySentError_1 = tslib_1.__importDefault(require("../exceptions/FriendshipRequestAlreadySentError"));
const InviterFriendshipsLimitExceededError_1 = tslib_1.__importDefault(require("../exceptions/InviterFriendshipsLimitExceededError"));
const InviteeFriendshipsLimitExceededError_1 = tslib_1.__importDefault(require("../exceptions/InviteeFriendshipsLimitExceededError"));
const InviteeFriendshipRequestLimitExceededError_1 = tslib_1.__importDefault(require("../exceptions/InviteeFriendshipRequestLimitExceededError"));
const InviteeFriendshipSettingsError_1 = tslib_1.__importDefault(require("../exceptions/InviteeFriendshipSettingsError"));
const IncomingPendingFriend_1 = tslib_1.__importDefault(require("../structures/friend/IncomingPendingFriend"));
const OutgoingPendingFriend_1 = tslib_1.__importDefault(require("../structures/friend/OutgoingPendingFriend"));
const BlockedUser_1 = tslib_1.__importDefault(require("../structures/user/BlockedUser"));
const ClientParty_1 = tslib_1.__importDefault(require("../structures/party/ClientParty"));
const SendMessageError_1 = tslib_1.__importDefault(require("../exceptions/SendMessageError"));
const Party_1 = tslib_1.__importDefault(require("../structures/party/Party"));
const PartyNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/PartyNotFoundError"));
const EpicgamesAPIError_1 = tslib_1.__importDefault(require("../exceptions/EpicgamesAPIError"));
const PartyPermissionError_1 = tslib_1.__importDefault(require("../exceptions/PartyPermissionError"));
const Tournament_1 = tslib_1.__importDefault(require("../structures/Tournament"));
const SentPartyJoinRequest_1 = tslib_1.__importDefault(require("../structures/party/SentPartyJoinRequest"));
const UserSearchResult_1 = tslib_1.__importDefault(require("../structures/user/UserSearchResult"));
const RadioStation_1 = tslib_1.__importDefault(require("../structures/RadioStation"));
const SentFriendMessage_1 = tslib_1.__importDefault(require("../structures/friend/SentFriendMessage"));
const MatchNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/MatchNotFoundError"));
const CreativeIslandNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/CreativeIslandNotFoundError"));
const Avatar_1 = tslib_1.__importDefault(require("../structures/Avatar"));
const GlobalProfile_1 = tslib_1.__importDefault(require("../structures/GlobalProfile"));
const OfferNotFoundError_1 = tslib_1.__importDefault(require("../exceptions/OfferNotFoundError"));
const STWProfile_1 = tslib_1.__importDefault(require("../structures/stw/STWProfile"));
const Stats_1 = tslib_1.__importDefault(require("../structures/Stats"));
const NewsMessage_1 = tslib_1.__importDefault(require("../structures/NewsMessage"));
const STWNewsMessage_1 = tslib_1.__importDefault(require("../structures/stw/STWNewsMessage"));
const EventTokens_1 = tslib_1.__importDefault(require("../structures/EventTokens"));
const EventTimeoutError_1 = tslib_1.__importDefault(require("../exceptions/EventTimeoutError"));
const FortniteServerStatus_1 = tslib_1.__importDefault(require("../structures/FortniteServerStatus"));
const EpicgamesServerStatus_1 = tslib_1.__importDefault(require("../structures/EpicgamesServerStatus"));
/**
 * Represets the main client
 */
class Client extends events_1.EventEmitter {
    /**
     * @param config The client's configuration options
     */
    constructor(config = {}) {
        var _a;
        super();
        this.config = {
            savePartyMemberMeta: true,
            http: {},
            debug: undefined,
            httpDebug: undefined,
            xmppDebug: undefined,
            defaultStatus: undefined,
            defaultOnlineType: Enums_1.default.PresenceOnlineType.ONLINE,
            platform: 'WIN',
            defaultPartyMemberMeta: {},
            xmppKeepAliveInterval: 30,
            createParty: true,
            forceNewParty: true,
            connectToXMPP: true,
            fetchFriends: true,
            restRetryLimit: 1,
            handleRatelimits: true,
            partyBuildId: '1:3:',
            restartOnInvalidRefresh: false,
            language: 'en',
            friendOnlineConnectionTimeout: 30000,
            ...config,
            cacheSettings: {
                ...config.cacheSettings,
                presences: {
                    maxLifetime: Infinity,
                    sweepInterval: 0,
                    ...(_a = config.cacheSettings) === null || _a === void 0 ? void 0 : _a.presences,
                },
            },
            auth: {
                authorizationCode: async () => (0, Util_1.consoleQuestion)('Please enter an authorization code: '),
                checkEULA: true,
                killOtherTokens: true,
                createLauncherSession: false,
                authClient: 'fortniteIOSGameClient',
                ...config.auth,
            },
            partyConfig: {
                privacy: Enums_1.default.PartyPrivacy.PUBLIC,
                joinConfirmation: false,
                joinability: 'OPEN',
                maxSize: 16,
                chatEnabled: true,
                discoverability: 'ALL',
                ...config.partyConfig,
            },
        };
        this.timeouts = new Set();
        this.intervals = new Set();
        this.auth = new Auth_1.default(this);
        this.http = new HTTP_1.default(this);
        this.xmpp = new XMPP_1.default(this);
        this.reauthLock = new AsyncLock_1.default();
        this.partyLock = new AsyncLock_1.default();
        this.cacheLock = new AsyncLock_1.default();
        this.user = undefined;
        this.isReady = false;
        this.friends = new collection_1.Collection();
        this.pendingFriends = new collection_1.Collection();
        this.blockedUsers = new collection_1.Collection();
        this.party = undefined;
        this.lastPartyMemberMeta = this.config.defaultPartyMemberMeta;
    }
    // Events
    on(event, listener) {
        return super.on(event, listener);
    }
    once(event, listener) {
        return super.once(event, listener);
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    /* -------------------------------------------------------------------------- */
    /*                           CLIENT LOGIN AND LOGOUT                          */
    /* -------------------------------------------------------------------------- */
    /**
     * Logs the client in.
     * A valid authentication method must be provided in the client's config.
     * By default, there will be a console prompt asking for an authorization code
     * @throws {EpicgamesAPIError}
     * @throws {EpicgamesGraphQLError}
     */
    async login() {
        const auth = await this.auth.authenticate();
        if (!auth.response)
            throw auth.error || new Error('Couldn\'t authenticate the client');
        const clientInfo = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_ID}/${auth.response.account_id}`, 'fortnite');
        if (!clientInfo.response)
            throw clientInfo.error || new Error('Couldn\'t fetch the client\'s account info');
        this.user = new ClientUser_1.default(this, clientInfo.response);
        await this.user.fetch();
        this.initCacheSweeping();
        this.cacheLock.lock();
        if (this.config.connectToXMPP) {
            this.xmpp.setup();
            const xmpp = await this.xmpp.connect();
            if (!xmpp.response)
                throw xmpp.error || new Error('Couldn\'t connect to XMPP');
        }
        if (this.config.fetchFriends) {
            await this.updateCaches();
        }
        this.cacheLock.unlock();
        await this.initParty(this.config.createParty, this.config.forceNewParty);
        this.setStatus();
        this.isReady = true;
        this.emit('ready');
    }
    /**
     * Logs the client out.
     * Also clears all caches, etc
     */
    async logout() {
        await this.auth.killAllTokens();
        await this.xmpp.disconnect();
        this.destroy();
        this.isReady = false;
        this.emit('disconnected');
    }
    /**
     * Restarts the client
     */
    async restart() {
        var _a;
        const refreshToken = (_a = this.auth.auths.get('fortnite')) === null || _a === void 0 ? void 0 : _a.refresh_token;
        await this.logout();
        this.config.auth.refreshToken = refreshToken;
        await this.login();
        this.config.auth.refreshToken = undefined;
    }
    /**
     * Initializes {@link Client#party}
     * @param createNew Whether to create a new party
     * @param forceNew Whether to force create a new party
     */
    async initParty(createNew = true, forceNew = true) {
        this.party = await this.getClientParty();
        if (!forceNew && this.party)
            return;
        if (createNew) {
            await this.leaveParty(false);
            await this.createParty();
        }
    }
    /**
     * Internal method that sets a {@link ClientParty} to the value of {@link Client#party}
     * @param party The party
     * @private
     */
    setClientParty(party) {
        this.party = new ClientParty_1.default(this, party);
    }
    /**
     * Waits until the client is ready
     * @param timeout How long to wait for until an error is thrown
     */
    async waitUntilReady(timeout = 10000) {
        if (this.isReady)
            return;
        this.setMaxListeners(this.getMaxListeners() + 1);
        try {
            await this.waitForEvent('ready', timeout);
        }
        finally {
            this.setMaxListeners(this.getMaxListeners() - 1);
        }
    }
    /**
     * Cleanup method
     */
    destroy() {
        // Clear timeouts
        for (const interval of this.intervals)
            clearInterval(interval);
        for (const timeout of this.timeouts)
            clearTimeout(timeout);
        this.timeouts.clear();
        this.intervals.clear();
        // Clear remaining caches
        this.friends.clear();
        this.pendingFriends.clear();
        this.blockedUsers.clear();
    }
    /**
     * Initializes the sweeping of cached objects
     */
    initCacheSweeping() {
        const { cacheSettings } = this.config;
        const presenceCacheSettings = cacheSettings.presences;
        if (presenceCacheSettings && presenceCacheSettings.sweepInterval && presenceCacheSettings.sweepInterval > 0
            && presenceCacheSettings.maxLifetime > 0 && presenceCacheSettings.maxLifetime !== Infinity) {
            this.setInterval(this.sweepPresences.bind(this), presenceCacheSettings.sweepInterval);
        }
    }
    /**
     * Updates the client's caches
     */
    async updateCaches() {
        var _a;
        const friendsSummary = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.FRIENDS}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/summary`, 'fortnite');
        if (friendsSummary.error)
            throw friendsSummary.error;
        this.friends.clear();
        this.pendingFriends.clear();
        this.blockedUsers.clear();
        friendsSummary.response.friends.forEach((f) => {
            this.friends.set(f.accountId, new Friend_1.default(this, { ...f, id: f.accountId }));
        });
        friendsSummary.response.incoming.forEach((f) => {
            this.pendingFriends.set(f.accountId, new IncomingPendingFriend_1.default(this, { ...f, id: f.accountId }));
        });
        friendsSummary.response.outgoing.forEach((f) => {
            this.pendingFriends.set(f.accountId, new OutgoingPendingFriend_1.default(this, { ...f, id: f.accountId }));
        });
        friendsSummary.response.blocklist.forEach((u) => {
            this.blockedUsers.set(u.accountId, new BlockedUser_1.default(this, { ...u, id: u.accountId }));
        });
        const users = await this.getProfile([...this.friends.values(), ...this.pendingFriends.values(), ...this.blockedUsers.values()]
            .filter((u) => !!u.id).map((u) => u.id));
        users.forEach((u) => {
            var _a, _b, _c;
            (_a = this.friends.get(u.id)) === null || _a === void 0 ? void 0 : _a.update(u);
            (_b = this.pendingFriends.get(u.id)) === null || _b === void 0 ? void 0 : _b.update(u);
            (_c = this.blockedUsers.get(u.id)) === null || _c === void 0 ? void 0 : _c.update(u);
        });
    }
    /**
     * Removes presences from the clients cache that are older than the max lifetime
     * @param maxLifetime How old a presence must be before it can be sweeped (in seconds)
     * @returns The amount of presences sweeped
     */
    sweepPresences(maxLifetime) {
        var _a, _b;
        if (maxLifetime === void 0) { maxLifetime = (_a = this.config.cacheSettings.presences) === null || _a === void 0 ? void 0 : _a.maxLifetime; }
        if (typeof maxLifetime !== 'number')
            throw new TypeError('maxLifetime must be typeof number');
        let presences = 0;
        for (const friend of this.friends.values()) {
            if (typeof ((_b = friend.presence) === null || _b === void 0 ? void 0 : _b.receivedAt) !== 'undefined' && Date.now() - friend.presence.receivedAt.getTime() > (maxLifetime * 1000)) {
                delete friend.presence;
                presences += 1;
            }
        }
        return presences;
    }
    /* -------------------------------------------------------------------------- */
    /*                                    UTIL                                    */
    /* -------------------------------------------------------------------------- */
    /**
     * Wait until an event is emitted
     * @param event The event that will be waited for
     * @param timeout The timeout (in milliseconds)
     * @param filter The filter for the event
     */
    waitForEvent(event, timeout = 5000, 
    // eslint-disable-next-line no-unused-vars
    filter) {
        return new Promise((res, rej) => {
            // eslint-disable-next-line no-undef
            let rejectionTimeout;
            const handler = (...data) => {
                if (!filter || filter(...data)) {
                    this.removeListener(event, handler);
                    if (rejectionTimeout)
                        clearTimeout(rejectionTimeout);
                    res(data);
                }
            };
            this.on(event, handler);
            const err = new EventTimeoutError_1.default(event, timeout);
            rejectionTimeout = setTimeout(() => {
                this.removeListener(event, handler);
                rej(err);
            }, timeout);
        });
    }
    /**
     * Sets a timeout that will be automatically cancelled if the client is logged out
     * @param fn Function to execute
     * @param delay Time to wait before executing (in milliseconds)
     * @param args Arguments for the function
     */
    // eslint-disable-next-line no-unused-vars
    setTimeout(fn, delay, ...args) {
        const timeout = setTimeout(() => {
            fn(args);
            this.timeouts.delete(timeout);
        }, delay);
        this.timeouts.add(timeout);
        return timeout;
    }
    /**
     * Clears a timeout
     * @param timeout Timeout to cancel
     */
    // eslint-disable-next-line no-undef
    clearTimeout(timeout) {
        clearTimeout(timeout);
        this.timeouts.delete(timeout);
    }
    /**
     * Sets an interval that will be automatically cancelled if the client is logged out
     * @param fn Function to execute
     * @param delay Time to wait between executions (in milliseconds)
     * @param args Arguments for the function
     */
    // eslint-disable-next-line no-unused-vars
    setInterval(fn, delay, ...args) {
        const interval = setInterval(fn, delay, ...args);
        this.intervals.add(interval);
        return interval;
    }
    /**
     * Clears an interval.
     * @param interval Interval to cancel
     */
    // eslint-disable-next-line no-undef
    clearInterval(interval) {
        clearInterval(interval);
        this.intervals.delete(interval);
    }
    static consoleQuestion(question) {
        return (0, Util_1.consoleQuestion)(question);
    }
    /**
     * Debug a message using the methods set in the client config
     * @param message Text to debug
     * @param type Debug type (regular, http or xmpp)
     */
    debug(message, type = 'regular') {
        switch (type) {
            case 'regular':
                if (typeof this.config.debug === 'function')
                    this.config.debug(message);
                break;
            case 'http':
                if (typeof this.config.httpDebug === 'function')
                    this.config.httpDebug(message);
                break;
            case 'xmpp':
                if (typeof this.config.xmppDebug === 'function')
                    this.config.xmppDebug(message);
                break;
        }
    }
    /**
     * Fetches one or multiple Epicgames accounts by id or display name
     * Returns undefined if the user(s) wasn't/weren't found
     * @param query An array of display names and/or account ids
     * @throws {EpicgamesAPIError}
     */
    async getProfile(query) {
        if (typeof query === 'string') {
            let user;
            if (query.length === 32) {
                user = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_MULTIPLE}?accountId=${query}`, 'fortnite');
            }
            else if (query.length >= 3 && query.length <= 16) {
                user = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_DISPLAYNAME}/${encodeURIComponent(query)}`, 'fortnite');
            }
            else
                return undefined;
            if (user === null || user === void 0 ? void 0 : user.error) {
                if (user.error.code === 'errors.com.epicgames.account.account_not_found')
                    return undefined;
                throw user.error;
            }
            if (Array.isArray(user.response) && !user.response[0])
                return undefined;
            return new User_1.default(this, Array.isArray(user === null || user === void 0 ? void 0 : user.response) ? user === null || user === void 0 ? void 0 : user.response[0] : user === null || user === void 0 ? void 0 : user.response);
        }
        const displayNames = [];
        const ids = [];
        query.forEach((q) => {
            if (q.length === 32)
                ids.push(q);
            else if (q.length >= 3 && q.length <= 16)
                displayNames.push(q);
        });
        const proms = [];
        proms.push(...displayNames
            .map((dn) => this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_DISPLAYNAME}/${encodeURIComponent(dn)}`, 'fortnite')));
        const idChunks = ids.reduce((resArr, id, i) => {
            const chunkIndex = Math.floor(i / 100);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(id);
            return resArr;
        }, []);
        proms.push(...idChunks
            .map((ic) => this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_MULTIPLE}?accountId=${ic.join('&accountId=')}`, 'fortnite')));
        const users = await Promise.all(proms);
        return users.map((u) => {
            if (u === null || u === void 0 ? void 0 : u.error) {
                if (u.error.code === 'errors.com.epicgames.account.account_not_found')
                    return undefined;
                throw u.error;
            }
            if (Array.isArray(u.response))
                return u.response.map((ur) => new User_1.default(this, ur));
            return new User_1.default(this, u.response);
        }).filter((u) => !!u).flat(1);
    }
    /**
     * Fetches users that match a prefix
     * @param prefix The prefix (a string that the user's display names start with)
     * @param platform The search platform. Other platform's accounts will still be searched with a lower priority
     */
    async searchProfiles(prefix, platform = 'epic') {
        var _a;
        const results = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_SEARCH}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}?prefix=${encodeURIComponent(prefix)}&platform=${platform}`, 'fortnite');
        if (results.error)
            throw results.error;
        const users = await this.getProfile(results.response.map((r) => r.accountId));
        return results.response.map((r) => new UserSearchResult_1.default(this, users.find((u) => u.id === r.accountId), r));
    }
    /**
     * Resolves a single user id
     * @param query Display name or id of the account's id to resolve
     */
    async resolveUserId(query) {
        var _a;
        if (query.length === 32)
            return query;
        return (_a = (await this.getProfile(query))) === null || _a === void 0 ? void 0 : _a.id;
    }
    /* -------------------------------------------------------------------------- */
    /*                                   FRIENDS                                  */
    /* -------------------------------------------------------------------------- */
    /**
     * Sets the clients XMPP status
     * @param status The status
     * @param onlineType The presence's online type (eg "away")
     * @param friend A specific friend you want to send this status to
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     */
    setStatus(status, onlineType, friend) {
        var _a, _b, _c;
        // eslint-disable-next-line no-undef-init
        let toJID = undefined;
        if (friend) {
            const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
            if (!resolvedFriend)
                throw new FriendNotFoundError_1.default(friend);
            toJID = `${resolvedFriend.id}@${Endpoints_1.default.EPIC_PROD_ENV}`;
        }
        // eslint-disable-next-line no-undef-init
        let partyJoinInfoData = undefined;
        if (this.party) {
            const partyPrivacy = this.party.config.privacy;
            if (partyPrivacy.presencePermission === 'Noone' || (partyPrivacy.presencePermission === 'Leader' && !((_a = this.party.me) === null || _a === void 0 ? void 0 : _a.isLeader))) {
                partyJoinInfoData = {
                    isPrivate: true,
                };
            }
            else {
                partyJoinInfoData = {
                    sourceId: (_b = this.user) === null || _b === void 0 ? void 0 : _b.id,
                    sourceDisplayName: (_c = this.user) === null || _c === void 0 ? void 0 : _c.displayName,
                    sourcePlatform: this.config.platform,
                    partyId: this.party.id,
                    partyTypeId: 286331153,
                    key: 'k',
                    appId: 'Fortnite',
                    buildId: this.config.partyBuildId,
                    partyFlags: -2024557306,
                    notAcceptingReason: 0,
                    pc: this.party.size,
                };
            }
        }
        if (status && !toJID)
            this.config.defaultStatus = status;
        if (onlineType && !toJID)
            this.config.defaultOnlineType = onlineType;
        const rawStatus = {
            Status: status || this.config.defaultStatus
                || (this.party && `Battle Royale Lobby - ${this.party.size} / ${this.party.maxSize}`) || 'Playing Battle Royale',
            bIsPlaying: false,
            bIsJoinable: this.party && !this.party.isPrivate && this.party.size !== this.party.maxSize,
            bHasVoiceSupport: false,
            SessionId: '',
            ProductName: 'Fortnite',
            Properties: {
                'party.joininfodata.286331153_j': partyJoinInfoData,
                FortBasicInfo_j: {
                    homeBaseRating: 0,
                },
                FortLFG_I: '0',
                FortPartySize_i: 1,
                FortSubGame_i: 1,
                InUnjoinableMatch_b: false,
                FortGameplayStats_j: {
                    state: '',
                    playlist: 'None',
                    numKills: 0,
                    bFellToDeath: false,
                },
            },
        };
        const rawOnlineType = (onlineType || this.config.defaultOnlineType) === 'online' ? undefined : (onlineType || this.config.defaultOnlineType);
        return this.xmpp.sendStatus(rawStatus, rawOnlineType, toJID);
    }
    /**
     * Resets the client's XMPP status and online type
     */
    async resetStatus() {
        this.config.defaultStatus = undefined;
        this.config.defaultOnlineType = 'online';
        return this.setStatus();
    }
    /**
     * Sends a friendship request to a user or accepts an existing request
     * @param friend The id or display name of the user to add
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {DuplicateFriendshipError} The user is already friends with the client
     * @throws {FriendshipRequestAlreadySentError} A friendship request has already been sent to the user
     * @throws {InviterFriendshipsLimitExceededError} The client's friendship limit is reached
     * @throws {InviteeFriendshipsLimitExceededError} The user's friendship limit is reached
     * @throws {InviteeFriendshipSettingsError} The user disabled friend requests
     * @throws {InviteeFriendshipRequestLimitExceededError} The user's incoming friend request limit is reached
     * @throws {EpicgamesAPIError}
     */
    async addFriend(friend) {
        var _a;
        const userID = await this.resolveUserId(friend);
        if (!userID)
            throw new UserNotFoundError_1.default(friend);
        const addFriend = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.FRIEND_ADD}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/${userID}`, 'fortnite');
        if (addFriend.error) {
            switch (addFriend.error.code) {
                case 'errors.com.epicgames.friends.duplicate_friendship':
                    throw new DuplicateFriendshipError_1.default(friend);
                case 'errors.com.epicgames.friends.friend_request_already_sent':
                    throw new FriendshipRequestAlreadySentError_1.default(friend);
                case 'errors.com.epicgames.friends.inviter_friendships_limit_exceeded':
                    throw new InviterFriendshipsLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.invitee_friendships_limit_exceeded':
                    throw new InviteeFriendshipsLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.incoming_friendships_limit_exceeded':
                    throw new InviteeFriendshipRequestLimitExceededError_1.default(friend);
                case 'errors.com.epicgames.friends.cannot_friend_due_to_target_settings':
                    throw new InviteeFriendshipSettingsError_1.default(friend);
                case 'errors.com.epicgames.friends.account_not_found':
                    throw new UserNotFoundError_1.default(friend);
                default:
                    throw addFriend.error;
            }
        }
    }
    /**
     * Removes a friend from the client's friend list or declines / aborts a pending friendship request
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async removeFriend(friend) {
        var _a;
        let resolvedFriend;
        resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            resolvedFriend = this.pendingFriends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const removeFriend = await this.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.FRIEND_DELETE}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/friends/${resolvedFriend.id}`, 'fortnite');
        if (removeFriend.error)
            throw removeFriend.error;
    }
    /**
     * Fetches the friends the client shares with a friend
     * @param friend The id or display name of the friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async getMutualFriends(friend) {
        var _a;
        const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const mutualFriends = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.FRIENDS}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/friends/${resolvedFriend.id}/mutual`, 'fortnite');
        if (mutualFriends.error)
            throw mutualFriends.error;
        return mutualFriends.response.map((f) => this.friends.get(f)).filter((f) => !!f);
    }
    /**
     * Checks whether a friend owns a specific offer
     * @param friend The id or display name of the friend
     * @param offerId The offer id
     * @throws {OfferNotFoundError} The offer does not exist or is not in the current storefront catalog
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {EpicgamesAPIError}
     */
    async checkFriendOfferOwnership(friend, offerId) {
        const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const giftData = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_GIFT_ELIGIBILITY}/recipient/${resolvedFriend.id}`
            + `/offer/${encodeURIComponent(offerId)}`, 'fortnite');
        if (giftData.error) {
            if (giftData.error.code === 'errors.com.epicgames.modules.gamesubcatalog.catalog_out_of_date')
                throw new OfferNotFoundError_1.default(offerId);
            if (giftData.error.code === 'errors.com.epicgames.modules.gamesubcatalog.purchase_not_allowed')
                return true;
            throw giftData.error;
        }
        return false;
    }
    /**
     * Blocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async blockUser(user) {
        var _a;
        const userID = await this.resolveUserId(user);
        if (!userID)
            throw new UserNotFoundError_1.default(user);
        const blockUser = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.FRIEND_BLOCK}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/${userID}`, 'fortnite');
        if (blockUser.error)
            throw blockUser.error;
    }
    /**
     * Unblocks a user
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async unblockUser(user) {
        var _a;
        const blockedUser = this.blockedUsers.find((u) => u.displayName === user || u.id === user);
        if (!blockedUser)
            throw new UserNotFoundError_1.default(user);
        const unblockUser = await this.http.sendEpicgamesRequest(true, 'DELETE', `${Endpoints_1.default.FRIEND_BLOCK}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}/${blockedUser.id}`, 'fortnite');
        if (unblockUser.error)
            throw unblockUser.error;
    }
    /**
     * Sends a message to a friend
     * @param friend The id or display name of the friend
     * @param content The message that will be sent
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {SendMessageError} The messant could not be sent
     */
    async sendFriendMessage(friend, content) {
        const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        if (!this.xmpp.isConnected)
            throw new SendMessageError_1.default('You\'re not connected via XMPP', 'FRIEND', resolvedFriend);
        const message = await this.xmpp.sendMessage(`${resolvedFriend.id}@${Endpoints_1.default.EPIC_PROD_ENV}`, content);
        if (!message)
            throw new SendMessageError_1.default('Message timeout exceeded', 'FRIEND', resolvedFriend);
        return new SentFriendMessage_1.default(this, {
            author: this.user, content, id: message.id, sentAt: new Date(),
        });
    }
    /* -------------------------------------------------------------------------- */
    /*                                   PARTIES                                  */
    /* -------------------------------------------------------------------------- */
    /**
     * Sends a party invitation to a friend
     * @param friend The friend that will receive the invitation
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {PartyAlreadyJoinedError} The user is already a member of this party
     * @throws {PartyMaxSizeReachedError} The party reached its max size
     * @throws {PartyNotFoundError} The client is not in party
     * @throws {EpicgamesAPIError}
     */
    async invite(friend) {
        if (!this.party)
            throw new PartyNotFoundError_1.default();
        return this.party.invite(friend);
    }
    /**
     * Joins a party by its id
     * @param id The party id
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched
     * @throws {PartyMaxSizeReachedError} The party has reached its max size
     * @throws {EpicgamesAPIError}
     */
    async joinParty(id) {
        const party = await this.getParty(id);
        return party.join(true);
    }
    /**
     * Creates a new party
     * @param config The party config
     * @throws {EpicgamesAPIError}
     */
    async createParty(config) {
        var _a, _b;
        if (this.party)
            await this.party.leave();
        this.partyLock.lock();
        const partyConfig = { ...this.config.partyConfig, ...config };
        const party = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_PARTY}/parties`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            config: {
                join_confirmation: partyConfig.joinConfirmation,
                joinability: partyConfig.joinability,
                max_size: partyConfig.maxSize,
            },
            join_info: {
                connection: {
                    id: this.xmpp.JID,
                    meta: {
                        'urn:epic:conn:platform_s': this.config.platform,
                        'urn:epic:conn:type_s': 'game',
                    },
                    yield_leadership: false,
                },
                meta: {
                    'urn:epic:member:dn_s': (_a = this.user) === null || _a === void 0 ? void 0 : _a.displayName,
                },
            },
            meta: {
                'urn:epic:cfg:party-type-id_s': 'default',
                'urn:epic:cfg:build-id_s': '1:3:',
                'urn:epic:cfg:join-request-action_s': 'Manual',
                'urn:epic:cfg:chat-enabled_b': ((_b = partyConfig.chatEnabled) === null || _b === void 0 ? void 0 : _b.toString()) || 'true',
                'urn:epic:cfg:can-join_b': 'true',
            },
        });
        if (party.error) {
            this.partyLock.unlock();
            if (party.error.code === 'errors.com.epicgames.social.party.user_has_party') {
                await this.leaveParty(false);
                return this.createParty(config);
            }
            throw party.error;
        }
        this.party = new ClientParty_1.default(this, party.response);
        const newPrivacy = await this.party.setPrivacy(partyConfig.privacy || Enums_1.default.PartyPrivacy.PUBLIC, false);
        await this.party.sendPatch({
            ...newPrivacy.updated,
            ...Object.keys(this.party.meta.schema).filter((k) => !k.startsWith('urn:'))
                // eslint-disable-next-line no-param-reassign
                .reduce((obj, key) => { var _a; obj[key] = (_a = this.party) === null || _a === void 0 ? void 0 : _a.meta.schema[key]; return obj; }, {}),
        }, newPrivacy.deleted);
        this.partyLock.unlock();
        await this.party.chat.join();
        return undefined;
    }
    /**
     * Leaves the client's current party
     * @param createNew Whether a new party should be created
     * @throws {EpicgamesAPIError}
     */
    async leaveParty(createNew = true) {
        if (!this.party)
            return undefined;
        return this.party.leave(createNew);
    }
    /**
     * Sends a party join request to a friend.
     * When the friend confirms this, a party invite will be sent to the client
     * @param friend The friend
     * @throws {FriendNotFoundError} The user does not exist or is not friends with the client
     * @throws {PartyNotFoundError} The friend is not in a party
     * @throws {EpicgamesAPIError}
     */
    async sendRequestToJoin(friend) {
        var _a;
        const resolvedFriend = this.friends.find((f) => f.displayName === friend || f.id === friend);
        if (!resolvedFriend)
            throw new FriendNotFoundError_1.default(friend);
        const intention = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_PARTY}/members/${resolvedFriend.id}/intentions/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            'urn:epic:invite:platformdata_s': '',
        });
        if (intention.error) {
            if (intention.error.code === 'errors.com.epicgames.social.party.user_has_no_party')
                throw new PartyNotFoundError_1.default();
            throw intention.error;
        }
        return new SentPartyJoinRequest_1.default(this, this.user, resolvedFriend, intention.response);
    }
    /**
     * Fetches the client's party
     * @throws {EpicgamesAPIError}
     */
    async getClientParty() {
        var _a, _b;
        const party = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_PARTY}/user/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}`, 'fortnite');
        if (party.error)
            throw party.error;
        if (!((_b = party.response) === null || _b === void 0 ? void 0 : _b.current[0]))
            return undefined;
        return new ClientParty_1.default(this, party.response.current[0]);
    }
    /**
     * Fetches a party by its id
     * @param id The party's id
     * @param raw Whether to return the raw party data
     * @throws {PartyNotFoundError} The party wasn't found
     * @throws {PartyPermissionError} The party cannot be fetched due to a permission error
     * @throws {EpicgamesAPIError}
     */
    async getParty(id, raw = false) {
        const party = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_PARTY}/parties/${id}`, 'fortnite');
        if (party.error) {
            if (party.error instanceof EpicgamesAPIError_1.default) {
                if (party.error.code === 'errors.com.epicgames.social.party.party_not_found')
                    throw new PartyNotFoundError_1.default();
                if (party.error.code === 'errors.com.epicgames.social.party.party_query_forbidden')
                    throw new PartyPermissionError_1.default();
            }
            else {
                throw party.error;
            }
        }
        if (raw)
            return party.response;
        const constuctedParty = new Party_1.default(this, party.response);
        await constuctedParty.updateMemberBasicInfo();
        return constuctedParty;
    }
    /* -------------------------------------------------------------------------- */
    /*                                  FORTNITE                                  */
    /* -------------------------------------------------------------------------- */
    /**
     * Fetches the current Fortnite server status (lightswitch)
     * @throws {EpicgamesAPIError}
     */
    async getFortniteServerStatus() {
        const fortniteServerStatus = await this.http.sendEpicgamesRequest(true, 'GET', Endpoints_1.default.BR_SERVER_STATUS, 'fortnite');
        if (fortniteServerStatus.error)
            throw fortniteServerStatus.error;
        return new FortniteServerStatus_1.default(this, fortniteServerStatus.response[0]);
    }
    /**
     * Fetches the current epicgames server status (https://status.epicgames.com/)
     * @throws {AxiosError}
     */
    async getEpicgamesServerStatus() {
        const epicgamesServerStatus = await this.http.send('GET', Endpoints_1.default.SERVER_STATUS_SUMMARY);
        if (epicgamesServerStatus.error)
            throw epicgamesServerStatus.error;
        if (!epicgamesServerStatus.response)
            throw new Error('Request returned an empty body');
        return new EpicgamesServerStatus_1.default(this, epicgamesServerStatus.response.data);
    }
    /**
     * Fetches the current Fortnite storefronts
     * @param language The language
     * @throws {EpicgamesAPIError}
     */
    async getStorefronts(language = 'en') {
        const store = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_STORE}?lang=${language}`, 'fortnite');
        if (store.error)
            throw store.error;
        return store.response.storefronts;
    }
    /**
     * Downloads a blurl stream (eg a radio station stream or a news video)
     * @param id The stream ID
     * @throws {AxiosError}
     */
    async downloadBlurlStream(id) {
        var _a;
        const blurlFile = await this.http.send('GET', `${Endpoints_1.default.BR_STREAM}/${id}/master.blurl`, undefined, undefined, undefined, 'arraybuffer');
        if (blurlFile.error)
            throw blurlFile.error;
        const streamData = await (0, Util_1.parseBlurlStream)((_a = blurlFile.response) === null || _a === void 0 ? void 0 : _a.data);
        const streamMetaData = {
            subtitles: streamData.subtitles ? JSON.parse(streamData.subtitles) : {},
            ucp: streamData.ucp,
            audioonly: !!streamData.audioonly,
            aspectratio: streamData.aspectratio,
            partysync: !!streamData.partysync,
            lrcs: streamData.lrcs ? JSON.parse(streamData.lrcs) : {},
            duration: streamData.duration,
        };
        const languageStreams = streamData.playlists.filter((p) => p.type === 'master').map((s) => {
            var _a, _b;
            let baseURL = (_a = s.url.match(/.+\//)) === null || _a === void 0 ? void 0 : _a[0];
            if (baseURL && !baseURL.endsWith('/'))
                baseURL += '/';
            const data = (0, Util_1.parseM3U8File)(s.data);
            let variants = data.streams.map((ss) => {
                var _a, _b;
                return ({
                    data: {
                        codecs: ((_a = ss.data.CODECS) === null || _a === void 0 ? void 0 : _a.split(',')) || [],
                        bandwidth: parseInt(ss.data.BANDWIDTH, 10),
                        resolution: ss.data.RESOLUTION,
                    },
                    type: ss.data.RESOLUTION ? 'video' : 'audio',
                    url: `${baseURL || ''}${ss.url}`,
                    stream: (_b = streamData.playlists
                        .find((p) => p.type === 'variant' && p.rel_url === ss.url)) === null || _b === void 0 ? void 0 : _b.data.split(/\n/).map((l) => (!l.startsWith('#') && l.length > 0 ? `${baseURL || ''}${l}` : l)).join('\n').replace(/init_/g, `${baseURL || ''}init_`),
                });
            });
            if (!streamMetaData.audioonly) {
                const audioStreamUrl = (_b = variants.find((v) => v.type === 'audio')) === null || _b === void 0 ? void 0 : _b.url;
                if (audioStreamUrl) {
                    variants = variants.map((v) => ({
                        ...v,
                        stream: Buffer.from(v.type !== 'video' ? v.stream : v.stream.replace('#EXTINF:', '#EXT-X-STREAM-INF:AUDIO="group_audio"\n'
                            + `#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="group_audio",NAME="audio",DEFAULT=YES,URI="${audioStreamUrl}"\n#EXTINF:`), 'utf8'),
                    }));
                }
            }
            return {
                language: s.language,
                url: s.url,
                variants,
            };
        });
        return {
            languages: languageStreams,
            data: streamMetaData,
        };
    }
    /**
     * Fetches the avatar for one or more users
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {EpicgamesAPIError}
     */
    async getUserAvatar(user) {
        const users = await this.getProfile(Array.isArray(user) ? user : [user]);
        const userChunks = users.reduce((resArr, u, i) => {
            const chunkIndex = Math.floor(i / 100);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(u);
            return resArr;
        }, []);
        const avatars = await Promise.all(userChunks
            .map((uc) => this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.ACCOUNT_AVATAR}/fortnite/ids?accountIds=${uc.map((u) => u.id).join(',')}`, 'fortnite')));
        return avatars.map((a) => {
            if (a.error && a.error.code !== 'errors.com.epicgames.account.account_not_found')
                throw a.error;
            return a.response.map((ar) => new Avatar_1.default(this, ar, users.find((u) => u.id === ar.accountId)));
        }).flat(1);
    }
    /**
     * Fetches the global profile for one or more users
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {EpicgamesAPIError}
     */
    async getGlobalProfile(user) {
        const users = await this.getProfile(Array.isArray(user) ? user : [user]);
        const userChunks = users.reduce((resArr, u, i) => {
            const chunkIndex = Math.floor(i / 100);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(u);
            return resArr;
        }, []);
        const globalProfiles = await Promise.all(userChunks
            .map((uc) => this.http.sendEpicgamesRequest(true, 'PUT', `${Endpoints_1.default.ACCOUNT_GLOBAL_PROFILE}`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            namespace: 'Fortnite',
            accountIds: uc.map((u) => u.id),
        })));
        return globalProfiles.map((a) => {
            if (a.error)
                throw a.error;
            return a.response.profiles.map((ar) => new GlobalProfile_1.default(this, ar, users.find((u) => u.id === ar.accountId)));
        }).flat(1);
    }
    /**
     * Fetches Battle Royale v2 stats for one or multiple players
     * @param user The id(s) or display name(s) of the user(s)
     * @param startTime The timestamp in seconds to start fetching stats from, can be null/undefined for lifetime
     * @param endTime The timestamp in seconds to stop fetching stats from, can be undefined for lifetime
     * @param stats An array of stats keys. Required if you want to get the stats of multiple users at once (If not, ignore this)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {StatsPrivacyError} The user set their stats to private
     * @throws {TypeError} You must provide an array of stats keys for multiple user lookup
     * @throws {EpicgamesAPIError}
     */
    async getBRStats(user, startTime, endTime, stats = []) {
        var _a;
        const params = [];
        if (startTime)
            params.push(`startTime=${startTime}`);
        if (endTime)
            params.push(`endTime=${endTime}`);
        const query = params[0] ? `?${params.join('&')}` : '';
        if (typeof user === 'string') {
            const resolvedUser = await this.getProfile(user);
            if (!resolvedUser)
                throw new UserNotFoundError_1.default(user);
            const statsResponse = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_STATS_V2}/account/${resolvedUser.id}${query}`, 'fortnite');
            if (!statsResponse.error && !statsResponse.response)
                throw new StatsPrivacyError_1.default(user);
            if (statsResponse.error)
                throw statsResponse.error;
            return new Stats_1.default(this, statsResponse.response, resolvedUser);
        }
        if (!stats[0])
            throw new TypeError('You need to provide an array of stats keys to fetch multiple user\'s stats');
        const resolvedUsers = await this.getProfile(user);
        const idChunks = resolvedUsers.map((u) => u.id).reduce((resArr, id, i) => {
            const chunkIndex = Math.floor(i / 51);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(id);
            return resArr;
        }, []);
        const statsResponses = await Promise.all(idChunks.map((c) => this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.BR_STATS_V2}/query${query}`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {
            appId: 'fortnite',
            owners: c,
            stats,
        })));
        if (statsResponses.some((r) => r.error))
            throw (_a = statsResponses.find((r) => r.error)) === null || _a === void 0 ? void 0 : _a.error;
        return statsResponses.map((r) => r.response).flat(1).map((r) => new Stats_1.default(this, r, resolvedUsers.find((u) => u.id === r.accountId)));
    }
    /**
     * Fetches the current Battle Royale news
     * @param language The language of the news
     * @param customPayload Extra data to send in the request body for a personalized news response (battle pass level, country, etc)
     * @throws {EpicgamesAPIError}
     */
    async getBRNews(language = Enums_1.default.Language.ENGLISH, customPayload) {
        const news = await this.http.sendEpicgamesRequest(true, 'POST', Endpoints_1.default.BR_NEWS_MOTD, 'fortnite', {
            'Content-Type': 'application/json',
            'Accept-Language': language,
        }, {
            platform: 'Windows',
            language,
            country: 'US',
            serverRegion: 'NA',
            subscription: false,
            battlepass: false,
            battlepassLevel: 1,
            ...customPayload,
        });
        if (news.error)
            throw news.error;
        return news.response.contentItems.map((i) => new NewsMessage_1.default(this, i));
    }
    /**
     * Fetches data for a Support-A-Creator code
     * @param code The Support-A-Creator code (slug)
     * @throws {CreatorCodeNotFoundError} The Support-A-Creator code wasnt found
     * @throws {EpicgamesAPIError}
     */
    async getCreatorCode(code) {
        const codeResponse = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_SAC}/${encodeURIComponent(code)}`, 'fortniteClientCredentials');
        if (codeResponse.error) {
            if (codeResponse.error.code === 'errors.com.epicgames.ecommerce.affiliate.not_found')
                throw new CreatorCodeNotFoundError_1.default(code);
            throw codeResponse.error;
        }
        const owner = await this.getProfile(codeResponse.response.id);
        return new CreatorCode_1.default(this, { ...codeResponse.response, owner });
    }
    /**
     * Fetches the current Fortnite Battle Royale radio stations
     * @throws {EpicgamesAPIError}
     */
    async getRadioStations() {
        const fortniteContent = await this.http.sendEpicgamesRequest(false, 'GET', Endpoints_1.default.BR_NEWS);
        if (fortniteContent.error)
            throw fortniteContent.error;
        const radioStations = fortniteContent.response.radioStations.radioStationList.stations;
        return radioStations.map((s) => new RadioStation_1.default(this, s));
    }
    /**
     * Fetches the current Battle Royale event flags
     * @param language The language
     * @throws {EpicgamesAPIError}
     */
    async getBREventFlags(language = 'en') {
        const eventFlags = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_EVENT_FLAGS}?lang=${language}`, 'fortnite');
        if (eventFlags.error)
            throw eventFlags.error;
        return eventFlags.response;
    }
    /**
     * Fetches the Battle Royale account level for one or multiple users
     * @param user The id(s) and/or display name(s) of the user(s) to fetch the account level for
     * @param seasonNumber The season number (eg. 16, 17, 18)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {StatsPrivacyError} The user set their stats to private
     * @throws {EpicgamesAPIError}
     */
    async getBRAccountLevel(user, seasonNumber) {
        const users = Array.isArray(user) ? user : [user];
        const accountLevels = await this.getBRStats(users, undefined, undefined, [`s${seasonNumber}_social_bp_level`]);
        return accountLevels.map((al) => ({
            user: al.user,
            level: al.levelData[`s${seasonNumber}`] || { level: 0, progress: 0 },
        }));
    }
    /**
     * Fetches the storefront keychain
     * @throws {EpicgamesAPIError}
     */
    async getStorefrontKeychain() {
        const keychain = await this.http.sendEpicgamesRequest(true, 'GET', Endpoints_1.default.BR_STORE_KEYCHAIN, 'fortnite');
        if (keychain.error)
            throw keychain.error;
        return keychain.response;
    }
    /* -------------------------------------------------------------------------- */
    /*                     FORTNITE BATTLE ROYALE TOURNAMENTS                     */
    /* -------------------------------------------------------------------------- */
    /**
     * Fetches the event tokens for an account.
     * This can be used to check if a user is eligible to play a certain tournament window
     * or to check a user's arena division in any season
     * @param user The id(s) or display name(s) of the user(s)
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async getEventTokens(user) {
        const users = typeof user === 'string' ? [user] : user;
        const resolvedUsers = await this.getProfile(users);
        const userChunks = resolvedUsers.map((u) => u.id).reduce((resArr, usr, i) => {
            const chunkIndex = Math.floor(i / 16);
            // eslint-disable-next-line no-param-reassign
            if (!resArr[chunkIndex])
                resArr[chunkIndex] = [];
            resArr[chunkIndex].push(usr);
            return resArr;
        }, []);
        const statsResponses = await Promise.all(userChunks.map((c) => this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_TOURNAMENT_TOKENS}?teamAccountIds=${c.join(',')}`, 'fortnite')));
        return statsResponses.map((r) => r.response.accounts).flat(1)
            .map((r) => new EventTokens_1.default(this, r.tokens, resolvedUsers.find((u) => u.id === r.accountId)));
    }
    /**
     * Fetches the current and past Battle Royale tournaments
     * @param region The region
     * @param platform The platform
     * @throws {EpicgamesAPIError}
     */
    async getTournaments(region = 'EU', platform = 'Windows') {
        var _a, _b;
        const [tournaments, tournamentsInfo] = await Promise.all([
            this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_TOURNAMENTS_DOWNLOAD}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}?region=${region}&platform=${platform}&teamAccountIds=${(_b = this.user) === null || _b === void 0 ? void 0 : _b.id}`, 'fortnite'),
            this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_NEWS}/tournamentinformation`, 'fortnite'),
        ]);
        if (tournaments.error)
            throw tournaments.error;
        if (tournamentsInfo.error)
            throw tournamentsInfo.error;
        const constuctedTournaments = [];
        tournaments.response.events.forEach((t) => {
            var _a, _b, _c;
            let tournamentDisplayData = (_b = (_a = tournamentsInfo.response.tournament_info) === null || _a === void 0 ? void 0 : _a.tournaments) === null || _b === void 0 ? void 0 : _b.find((td) => td.tournament_display_id === t.displayDataId);
            if (!tournamentDisplayData) {
                tournamentDisplayData = (_c = Object.values(tournamentsInfo.response)
                    .find((tdr) => { var _a; return ((_a = tdr.tournament_info) === null || _a === void 0 ? void 0 : _a.tournament_display_id) === t.displayDataId; })) === null || _c === void 0 ? void 0 : _c.tournament_info;
            }
            if (!tournamentDisplayData) {
                return;
            }
            const templates = [];
            t.eventWindows.forEach((w) => {
                const template = tournaments.response.templates.find((tt) => tt.eventTemplateId === w.eventTemplateId);
                if (template)
                    templates.push({ windowId: w.eventWindowId, templateData: template });
            });
            constuctedTournaments.push(new Tournament_1.default(this, t, tournamentDisplayData, templates));
        });
        return constuctedTournaments;
    }
    /**
     * Fetches the results for a tournament window
     * @param eventId The tournament's ID
     * @param eventWindowId The tournament window's ID
     * @param showLiveSessions Whether to show live sessions
     * @param page The results page index
     * @throws {EpicgamesAPIError}
     */
    async getTournamentWindowResults(eventId, eventWindowId, showLiveSessions = false, page = 0) {
        var _a;
        const window = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_TOURNAMENT_WINDOW}/${eventId}/${eventWindowId}/`
            + `${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}?page=${page}&rank=0&teamAccountIds=&appId=Fortnite&showLiveSessions=${showLiveSessions}`, 'fortnite');
        if (window.error)
            throw window.error;
        return window.response;
    }
    /**
     * Downloads a tournament replay by its session ID.
     * This method returns a regular Fortnite replay file, can be parsed using https://github.com/ThisNils/node-replay-reader
     * @param sessionId The session ID
     * @param options Replay download and build options
     * @throws {MatchNotFoundError} The match wasn't found
     * @throws {EpicgamesAPIError}
     * @throws {AxiosError}
     */
    async downloadTournamentReplay(sessionId, options) {
        var _a, _b;
        const downloadConfig = {
            dataTypes: ['EVENT', 'DATACHUNK'],
            addStatsPlaceholder: false,
            ...options,
        };
        const replayMetadataResponse = await this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY_METADATA}%2F${sessionId}.json`, 'json');
        if (replayMetadataResponse.error) {
            if (!(replayMetadataResponse.error instanceof EpicgamesAPIError_1.default) && typeof ((_a = replayMetadataResponse.error.response) === null || _a === void 0 ? void 0 : _a.data) === 'string'
                && ((_b = replayMetadataResponse.error.response) === null || _b === void 0 ? void 0 : _b.data.includes('<Message>The specified key does not exist.</Message>'))) {
                throw new MatchNotFoundError_1.default(sessionId);
            }
            throw replayMetadataResponse.error;
        }
        const replayHeaderResponse = await this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY}%2F${sessionId}%2Fheader.bin`, 'arraybuffer');
        if (replayHeaderResponse.error)
            throw replayHeaderResponse.error;
        const replayData = replayMetadataResponse.response;
        replayData.Header = replayHeaderResponse.response;
        const downloadKeys = new Set(['Events', 'DataChunks', 'Checkpoints']);
        if (!downloadConfig.dataTypes.includes('EVENT')) {
            downloadKeys.delete('Events');
            delete replayData.Events;
        }
        if (!downloadConfig.dataTypes.includes('DATACHUNK')) {
            downloadKeys.delete('DataChunks');
            delete replayData.DataChunks;
        }
        if (!downloadConfig.dataTypes.includes('CHECKPOINT')) {
            downloadKeys.delete('Checkpoints');
            delete replayData.Checkpoints;
        }
        const promises = [];
        for (const downloadKey of downloadKeys.values()) {
            const chunks = replayData[downloadKey];
            for (const chunk of chunks) {
                promises.push(this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY}%2F${sessionId}%2F${chunk.Id}.bin`, 'arraybuffer').then((resp) => {
                    if (resp.error)
                        throw resp.error;
                    chunks.find((d) => d.Id === chunk.Id).data = resp.response;
                }));
            }
        }
        await Promise.all(promises);
        return (0, Util_1.buildReplay)(replayData, downloadConfig.addStatsPlaceholder);
    }
    /**
     * Fetches a tournament session's metadata
     * @param sessionId The session ID
     * @throws {MatchNotFoundError} The match wasn't found
     * @throws {EpicgamesAPIError}
     * @throws {AxiosError}
     */
    async getTournamentSessionMetadata(sessionId) {
        var _a, _b;
        const replayMetadataResponse = await this.downloadReplayCDNFile(`${Endpoints_1.default.BR_REPLAY_METADATA}%2F${sessionId}.json`, 'json');
        if (replayMetadataResponse.error) {
            if (!(replayMetadataResponse.error instanceof EpicgamesAPIError_1.default) && typeof ((_a = replayMetadataResponse.error.response) === null || _a === void 0 ? void 0 : _a.data) === 'string'
                && ((_b = replayMetadataResponse.error.response) === null || _b === void 0 ? void 0 : _b.data.includes('<Message>The specified key does not exist.</Message>'))) {
                throw new MatchNotFoundError_1.default(sessionId);
            }
            throw replayMetadataResponse.error;
        }
        return {
            changelist: replayMetadataResponse.response.Changelist,
            checkpoints: replayMetadataResponse.response.Checkpoints,
            dataChunks: replayMetadataResponse.response.DataChunks,
            desiredDelayInSeconds: replayMetadataResponse.response.DesiredDelayInSeconds,
            events: replayMetadataResponse.response.Events,
            friendlyName: replayMetadataResponse.response.FriendlyName,
            lengthInMS: replayMetadataResponse.response.LengthInMS,
            networkVersion: replayMetadataResponse.response.NetworkVersion,
            replayName: replayMetadataResponse.response.ReplayName,
            timestamp: new Date(replayMetadataResponse.response.Timestamp),
            isCompressed: replayMetadataResponse.response.bCompressed,
            isLive: replayMetadataResponse.response.bIsLive,
        };
    }
    /**
     * Downloads a file from the CDN (used for replays)
     * @param url The URL of the file to download
     * @param responseType The response type
     */
    async downloadReplayCDNFile(url, responseType) {
        const fileLocationInfo = await this.http.sendEpicgamesRequest(true, 'GET', url, 'fortnite');
        if (fileLocationInfo.error)
            return fileLocationInfo;
        const file = await this.http.send('GET', Object.values(fileLocationInfo.response.files)[0].readLink, undefined, undefined, undefined, responseType);
        if (file.response)
            return { response: file.response.data };
        return file;
    }
    /* -------------------------------------------------------------------------- */
    /*                              FORTNITE CREATIVE                             */
    /* -------------------------------------------------------------------------- */
    /**
     * Fetches a creative island by its code
     * @param code The island code
     * @throws {CreativeIslandNotFoundError} A creative island with the provided code does not exist
     * @throws {EpicgamesAPIError}
     */
    async getCreativeIsland(code) {
        const islandInfo = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.CREATIVE_ISLAND_LOOKUP}/${code}`, 'fortnite');
        if (islandInfo.error) {
            if (islandInfo.error.code === 'errors.com.epicgames.links.no_active_version')
                throw new CreativeIslandNotFoundError_1.default(code);
            throw islandInfo.error;
        }
        return islandInfo.response;
    }
    /**
     * Fetches the creative discovery surface
     * @param gameVersion The current game version (MAJOR.MINOR)
     * @throws {EpicgamesAPIError}
     */
    async getCreativeDiscoveryPanels(gameVersion = '19.40', region) {
        var _a, _b;
        const creativeDiscovery = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.CREATIVE_DISCOVERY}/${(_a = this.user) === null || _a === void 0 ? void 0 : _a.id}?appId=Fortnite`, 'fortnite', {
            'Content-Type': 'application/json',
            'User-Agent': `Fortnite/++Fortnite+Release-${gameVersion}-CL-00000000 Windows/10.0.19044.1.768.64bit`,
        }, {
            surfaceName: 'CreativeDiscoverySurface_Frontend',
            revision: -1,
            partyMemberIds: [(_b = this.user) === null || _b === void 0 ? void 0 : _b.id],
            matchmakingRegion: region,
        });
        if (creativeDiscovery.error) {
            throw creativeDiscovery.error;
        }
        return creativeDiscovery.response;
    }
    /* -------------------------------------------------------------------------- */
    /*                           FORTNITE SAVE THE WORLD                          */
    /* -------------------------------------------------------------------------- */
    /**
     * Fetches the Save The World profile for a players
     * @param user The id or display name of the user
     * @throws {UserNotFoundError} The user wasn't found
     * @throws {EpicgamesAPIError}
     */
    async getSTWProfile(user) {
        const resolvedUser = await this.getProfile(user);
        if (!resolvedUser)
            throw new UserNotFoundError_1.default(user);
        const queryProfileResponse = await this.http.sendEpicgamesRequest(true, 'POST', `${Endpoints_1.default.MCP}/${resolvedUser.id}/public/QueryPublicProfile?profileId=campaign`, 'fortnite', {
            'Content-Type': 'application/json',
        }, {});
        if (queryProfileResponse.error) {
            if (queryProfileResponse.error.code === 'errors.com.epicgames.modules.profiles.profile_not_found') {
                throw new UserNotFoundError_1.default(user);
            }
            throw queryProfileResponse.error;
        }
        return new STWProfile_1.default(this, queryProfileResponse.response.profileChanges[0].profile, resolvedUser);
    }
    /**
     * Fetches the current Save The World news
     * @param language The language of the news
     * @throws {EpicgamesAPIError}
     */
    async getSTWNews(language = this.config.language) {
        const newsResponse = await this.http.sendEpicgamesRequest(true, 'GET', `${Endpoints_1.default.BR_NEWS}/savetheworldnews?lang=${language}`, 'fortnite', {
            'Accept-Language': language,
        });
        if (newsResponse.error)
            throw newsResponse.error;
        return newsResponse.response.news.messages.map((m) => new STWNewsMessage_1.default(this, m));
    }
    /**
     * Fetches the current Save The World world info
     * @param language The language of the world info
     * @throws {EpicgamesAPIError}
     */
    async getSTWWorldInfo(language = this.config.language) {
        const worldInfoResponse = await this.http.sendEpicgamesRequest(true, 'GET', Endpoints_1.default.STW_WORLD_INFO, 'fortnite', {
            'Accept-Language': language,
        });
        if (worldInfoResponse.error)
            throw worldInfoResponse.error;
        return {
            theaters: worldInfoResponse.response.theaters,
            missions: worldInfoResponse.response.missions,
            missionAlerts: worldInfoResponse.response.missionAlerts,
        };
    }
}
exports.default = Client;
//# sourceMappingURL=Client.js.map